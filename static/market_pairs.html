<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantNetX - Market Pairs</title>
    <link rel="icon" type="image/png" href="assets/quantnetx_minilogo.png">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-title">
                <img src="assets/quantnetx_minilogo.png" alt="QuantNetX" class="minilogo">
                <h1>QuantNetX</h1>
            </div>
            <p class="subtitle">Market Pairs Analysis</p>
        </header>

        <nav class="nav-bar">
            <a href="market_pairs.html" class="nav-link active">Market Pairs</a>
            <a href="bitcoin_risk.html" class="nav-link">Bitcoin Risk Metric</a>
            <a href="index.html" class="nav-link">Options Analysis</a>
        </nav>

        <div class="info-box">
            <strong>Market Pairs Analysis:</strong> Compare relative performance between different assets.
            Select two symbols to create a trading pair ratio chart (e.g., BTC/Gold, SP500/NASDAQ).
            The chart shows the ratio of the first asset divided by the second asset over time.
            The page automatically uses the longest available historical data (monthly data for SP500 since 1935, Gold since 1935, Oil since 1961).
            <br><br>
            <strong>Power Law Model:</strong> R(t) = R(0) · exp(μ·t), where μ is the exponential growth rate (annualized).
            The dashed orange line shows the fitted exponential trend with ±1σ parallel bands.
            <br><br>
            <strong>Risk Color Coding:</strong> The price markers are colored based on deviation from the power law trend.
            Green = undervalued (below trend), Blue = fair value (near trend), Orange/Red = overvalued (above trend).
            See the color scale legend on the chart for exact σ values.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="numeratorSelect">Numerator</label>
                <select id="numeratorSelect">
                    <option value="">Select asset...</option>
                    <option value="sp500" selected>S&P 500</option>
                    <option value="nasdaq">NASDAQ</option>
                    <option value="vti">VTI (Total Stock)</option>
                    <option value="eem">EEM (Emerging Markets)</option>
                    <option value="gold">Gold</option>
                    <option value="silver">Silver</option>
                    <option value="palladium">Palladium</option>
                    <option value="copper">Copper</option>
                    <option value="oil">Oil (WTI)</option>
                    <option value="tlt">TLT (20Y Treasury)</option>
                    <option value="btc">Bitcoin (BTC)</option>
                    <option value="cpi">CPI (Consumer Price Index)</option>
                    <option value="usd">USD (Cash)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="denominatorSelect">Denominator</label>
                <select id="denominatorSelect">
                    <option value="">Select asset...</option>
                    <option value="sp500">S&P 500</option>
                    <option value="nasdaq">NASDAQ</option>
                    <option value="vti">VTI (Total Stock)</option>
                    <option value="eem">EEM (Emerging Markets)</option>
                    <option value="gold">Gold</option>
                    <option value="silver">Silver</option>
                    <option value="palladium">Palladium</option>
                    <option value="copper">Copper</option>
                    <option value="oil">Oil (WTI)</option>
                    <option value="tlt">TLT (20Y Treasury)</option>
                    <option value="btc">Bitcoin (BTC)</option>
                    <option value="cpi">CPI (Consumer Price Index)</option>
                    <option value="usd" selected>USD (Cash)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="scaleSelect">Scale</label>
                <select id="scaleSelect">
                    <option value="linear">Linear</option>
                    <option value="log" selected>Logarithmic</option>
                </select>
            </div>
            <div class="control-group">
                <label for="normalizeCheck">
                    <input type="checkbox" id="normalizeCheck"> Normalize to 100
                </label>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">Loading data...</div>
        <div id="stats" class="stats-grid" style="display: none;"></div>

        <div class="chart-container" id="pairChartContainer" style="display: none;">
            <div id="pairChart" style="width: 100%; height: 600px;"></div>
        </div>

        <div class="chart-container" id="riskMatrixContainer">
            <h3 style="color: #e4e4e4; margin-bottom: 15px;">Risk Matrix - Current Valuation of All Pairs</h3>
            <div id="riskMatrix" style="width: 100%; height: 900px;"></div>
        </div>

        <div class="chart-container" id="networkGraphContainer">
            <h3 style="color: #e4e4e4; margin-bottom: 15px;">Asset Network Graph</h3>
            <p style="color: #a0a0a0; font-size: 0.9em; margin-top: -10px; margin-bottom: 15px;">
                Nodes colored by average risk (same as "Average Risk by Asset"). Arrows point from undervalued to overvalued assets. Node proximity indicates similar risk patterns across all pairs.
            </p>
            <div id="networkGraph" style="width: 100%; height: 800px;"></div>
        </div>

        <div class="chart-container" id="averageRiskContainer">
            <h3 style="color: #e4e4e4; margin-bottom: 15px;">Average Risk by Asset</h3>
            <div id="averageRiskChart" style="width: 100%; height: 500px;"></div>
        </div>

        <div class="chart-container" id="combinedMetricsContainer">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #e4e4e4; margin: 0;">Growth & Risk-Adjusted Returns</h3>
                <div class="control-group" style="margin: 0;">
                    <label for="ratioMetricSelect" style="margin-right: 10px; color: #a0a0a0;">Risk-Adjusted Metric:</label>
                    <select id="ratioMetricSelect" style="padding: 5px 10px; background: rgba(255, 255, 255, 0.1); color: #e4e4e4; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px;">
                        <option value="sharpe">Sharpe Ratio</option>
                        <option value="sortino">Sortino Ratio</option>
                    </select>
                </div>
            </div>
            <p style="color: #a0a0a0; font-size: 0.85em; margin-top: 0; margin-bottom: 15px;" id="ratioDescription">
                Sharpe Ratio: Measures risk-adjusted return using total volatility. Higher is better. Note: Bitcoin CAGR (~55.6%) excluded from left chart to maintain readable scale.
            </p>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                <div id="averageCAGRChart" style="width: 100%; height: 450px;"></div>
                <div id="ratioMetricsChart" style="width: 100%; height: 450px;"></div>
            </div>
        </div>

        <div class="chart-container" id="riskReturnScatterContainer">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #e4e4e4; margin: 0;">Risk-Return Trade-off</h3>
                <div class="control-group" style="margin: 0;">
                    <label for="scatterMetricSelect" style="margin-right: 10px; color: #a0a0a0;">Color by:</label>
                    <select id="scatterMetricSelect" style="padding: 5px 10px; background: rgba(255, 255, 255, 0.1); color: #e4e4e4; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px;">
                        <option value="sharpe">Sharpe Ratio</option>
                        <option value="sortino" selected>Sortino Ratio</option>
                    </select>
                </div>
            </div>
            <p style="color: #a0a0a0; font-size: 0.9em; margin-top: 0; margin-bottom: 5px;" id="scatterDescription">
                Annualized return vs annualized volatility. Color indicates Sortino ratio (darker green = better risk-adjusted returns).
            </p>
            <p style="color: #ff9800; font-size: 0.85em; margin-top: 0; margin-bottom: 15px;">
                <strong>Note:</strong> Assets have different historical timeframes. S&P 500 and Gold have data since 1935, Oil since 1961, Bitcoin since 2014. Ratios computed over different periods may not be directly comparable.
            </p>
            <div id="riskReturnScatter" style="width: 100%; height: 600px;"></div>
        </div>

        <div class="chart-container" id="returnDistributionContainer">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #e4e4e4; margin: 0;">Return Distribution</h3>
                <div class="control-group" style="margin: 0;">
                    <label for="distributionAssetSelect" style="margin-right: 10px; color: #a0a0a0;">Asset:</label>
                    <select id="distributionAssetSelect" style="padding: 5px 10px; background: rgba(255, 255, 255, 0.1); color: #e4e4e4; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px;">
                        <option value="btc">Bitcoin</option>
                        <option value="sp500" selected>S&P 500</option>
                        <option value="nasdaq">NASDAQ</option>
                        <option value="vti">VTI</option>
                        <option value="eem">EEM</option>
                        <option value="gold">Gold</option>
                        <option value="silver">Silver</option>
                        <option value="palladium">Palladium</option>
                        <option value="copper">Copper</option>
                        <option value="oil">Oil (WTI)</option>
                        <option value="tlt">TLT</option>
                    </select>
                </div>
            </div>
            <p style="color: #a0a0a0; font-size: 0.9em; margin-top: 0; margin-bottom: 15px;" id="distributionDescription">
                Histogram showing probability distribution of weekly returns. All returns normalized to 7-day periods for comparability across assets with different data frequencies.
            </p>
            <div id="returnDistributionChart" style="width: 100%; height: 500px;"></div>
        </div>
    </div>

    <script>
        // Market data cache
        const marketData = {};
        let powerLawFits = null;  // Power law fits cache

        const SYMBOL_NAMES = {
            'btc': 'Bitcoin',
            'sp500': 'S&P 500',
            'nasdaq': 'NASDAQ',
            'vti': 'VTI',
            'eem': 'EEM',
            'gold': 'Gold',
            'silver': 'Silver',
            'palladium': 'Palladium',
            'copper': 'Copper',
            'oil': 'Oil (WTI)',
            'tlt': 'TLT',
            'cpi': 'CPI',
            'usd': 'USD'
        };

        // ============================================================================
        // Utility Functions
        // ============================================================================

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function formatNumber(num, decimals = 2) {
            if (!num || num === '' || isNaN(num)) return '-';
            const n = parseFloat(num);

            // Format to 6 significant figures
            const sigFigs = 6;

            // Use toPrecision to get 6 significant figures
            let formatted = n.toPrecision(sigFigs);

            // Parse back to remove unnecessary trailing zeros and scientific notation
            formatted = parseFloat(formatted);

            // Add thousand separators using toLocaleString
            // We need to preserve the precision from toPrecision
            const str = formatted.toString();
            const parts = str.split('.');

            if (parts.length === 1) {
                // No decimal part
                return formatted.toLocaleString('en-US');
            } else {
                // Has decimal part - preserve it
                const decimalPlaces = parts[1].length;
                return formatted.toLocaleString('en-US', {
                    minimumFractionDigits: decimalPlaces,
                    maximumFractionDigits: decimalPlaces
                });
            }
        }

        // ============================================================================
        // Data Loading
        // ============================================================================

        async function loadPowerLawFits() {
            if (powerLawFits) {
                return powerLawFits;
            }

            try {
                const response = await fetch('../data/power_law_fits.json');
                if (!response.ok) {
                    console.warn('Power law fits not available');
                    return null;
                }

                const data = await response.json();
                powerLawFits = data.fits;
                return powerLawFits;
            } catch (error) {
                console.warn('Could not load power law fits:', error);
                return null;
            }
        }

        async function loadMarketData(symbol) {
            // Return cached data if available
            if (marketData[symbol]) {
                return marketData[symbol];
            }

            // USD is always 1.0
            if (symbol === 'usd') {
                marketData['usd'] = { constant: true, value: 1.0 };
                return marketData['usd'];
            }

            // Special handling for CPI data
            if (symbol === 'cpi') {
                try {
                    const response = await fetch(`../data/market_data/cpi_fred.csv`);
                    if (!response.ok) {
                        throw new Error(`Failed to load CPI data: HTTP ${response.status}`);
                    }

                    const csvText = await response.text();
                    const lines = csvText.trim().split('\n');

                    const data = {
                        dates: [],
                        timestamps: [],
                        open: [],
                        high: [],
                        low: [],
                        close: [],
                        volume: []
                    };

                    // Parse CPI CSV data (observation_date, CPILFESL)
                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',');
                        if (values.length >= 2) {
                            const date = values[0];
                            const cpiValue = parseFloat(values[1]);

                            data.dates.push(date);
                            data.timestamps.push(new Date(date).getTime());
                            // Use CPI value for all price fields
                            data.open.push(cpiValue);
                            data.high.push(cpiValue);
                            data.low.push(cpiValue);
                            data.close.push(cpiValue);
                            data.volume.push(0); // No volume for CPI
                        }
                    }

                    marketData[symbol] = data;
                    console.log(`Loaded ${symbol}: ${data.dates.length} points (${data.dates[0]} to ${data.dates[data.dates.length-1]})`);
                    return data;

                } catch (error) {
                    console.error(`Error loading CPI data:`, error);
                    throw new Error(`Failed to load CPI: ${error.message}`);
                }
            }

            // Load merged data file (combines all timeframes)
            try {
                const response = await fetch(`../data/market_data/${symbol}.csv`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${symbol} data: HTTP ${response.status}`);
                }

                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');

                const data = {
                    dates: [],
                    timestamps: [],
                    open: [],
                    high: [],
                    low: [],
                    close: [],
                    volume: []
                };

                // Parse CSV data
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length >= 7) {
                        data.dates.push(values[0]);
                        data.timestamps.push(parseInt(values[1]));
                        data.open.push(parseFloat(values[2]));
                        data.high.push(parseFloat(values[3]));
                        data.low.push(parseFloat(values[4]));
                        data.close.push(parseFloat(values[5]));
                        data.volume.push(parseFloat(values[6]));
                    }
                }

                marketData[symbol] = data;
                console.log(`Loaded ${symbol}: ${data.dates.length} points (${data.dates[0]} to ${data.dates[data.dates.length-1]})`);
                return data;

            } catch (error) {
                console.error(`Error loading ${symbol} data from ../data/market_data/${symbol}.csv:`, error);
                throw new Error(`Failed to load ${symbol}: ${error.message}`);
            }
        }

        // ============================================================================
        // Data Processing
        // ============================================================================

        function alignDataByDate(data1, data2) {
            // For USD constant value
            if (data1.constant) {
                return {
                    dates: data2.dates,
                    timestamps: data2.timestamps,
                    values1: Array(data2.dates.length).fill(1.0),
                    values2: data2.close
                };
            }
            if (data2.constant) {
                return {
                    dates: data1.dates,
                    timestamps: data1.timestamps,
                    values1: data1.close,
                    values2: Array(data1.dates.length).fill(1.0)
                };
            }

            // Find common dates
            const dates1Set = new Set(data1.dates);
            const dates2Map = {};

            data2.dates.forEach((date, i) => {
                dates2Map[date] = i;
            });

            const aligned = {
                dates: [],
                timestamps: [],
                values1: [],
                values2: []
            };

            data1.dates.forEach((date, i) => {
                if (dates2Map.hasOwnProperty(date)) {
                    const j = dates2Map[date];
                    aligned.dates.push(date);
                    aligned.timestamps.push(data1.timestamps[i]);
                    aligned.values1.push(data1.close[i]);
                    aligned.values2.push(data2.close[j]);
                }
            });

            return aligned;
        }

        function calculatePairRatio(aligned, normalize = false) {
            const ratios = aligned.values1.map((v1, i) => v1 / aligned.values2[i]);

            if (normalize && ratios.length > 0) {
                const firstRatio = ratios[0];
                return ratios.map(r => (r / firstRatio) * 100);
            }

            return ratios;
        }

        function calculateStatistics(ratios) {
            if (ratios.length === 0) return null;

            const current = ratios[ratios.length - 1];
            const start = ratios[0];
            const change = ((current - start) / start) * 100;
            const max = Math.max(...ratios);
            const min = Math.min(...ratios);
            const mean = ratios.reduce((a, b) => a + b, 0) / ratios.length;

            return { current, start, change, max, min, mean };
        }

        // Calculate returns from price series
        function calculateReturns(prices) {
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
                returns.push((prices[i] - prices[i-1]) / prices[i-1]);
            }
            return returns;
        }

        // Calculate Sharpe Ratio (annualized, assuming risk-free rate = 0)
        function calculateSharpeRatio(returns, periodsPerYear = 252) {
            if (returns.length === 0) return null;

            const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length;
            const stdDev = Math.sqrt(variance);

            if (stdDev === 0) return null;

            // Annualized Sharpe Ratio
            const annualizedReturn = meanReturn * periodsPerYear;
            const annualizedStdDev = stdDev * Math.sqrt(periodsPerYear);

            return annualizedReturn / annualizedStdDev;
        }

        // Calculate Sortino Ratio (annualized, assuming risk-free rate = 0)
        function calculateSortinoRatio(returns, periodsPerYear = 252) {
            if (returns.length === 0) return null;

            const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;

            // Calculate downside deviation (only consider returns below the target/mean)
            // Target return is 0 (risk-free rate)
            const downsideSquaredSum = returns.reduce((sum, r) => {
                return sum + (r < 0 ? Math.pow(r, 2) : 0);
            }, 0);

            // Divide by total number of returns (not just negative ones)
            const downsideVariance = downsideSquaredSum / returns.length;
            const downsideStdDev = Math.sqrt(downsideVariance);

            if (downsideStdDev === 0) return null;

            // Annualized Sortino Ratio
            const annualizedReturn = meanReturn * periodsPerYear;
            const annualizedDownsideStdDev = downsideStdDev * Math.sqrt(periodsPerYear);

            return annualizedReturn / annualizedDownsideStdDev;
        }

        // ============================================================================
        // Visualization
        // ============================================================================

        function updateStats(stats, numSymbol, denomSymbol, normalize, powerLawFit, currentRisk) {
            const statsDiv = document.getElementById('stats');

            const pairName = normalize ?
                `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]} (Normalized)` :
                `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]}`;

            let powerLawStatsHtml = '';
            if (powerLawFit && !isNaN(powerLawFit.drift_annual) && !isNaN(powerLawFit.volatility_annual)) {
                powerLawStatsHtml = `
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">Annualized Growth Rate</div>
                        <div class="stat-value">${powerLawFit.drift_annual >= 0 ? '+' : ''}${formatNumber(powerLawFit.drift_annual * 100, 2)}%</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">Annualized Volatility</div>
                        <div class="stat-value">${formatNumber(powerLawFit.volatility_annual * 100, 2)}%</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">R²</div>
                        <div class="stat-value">${formatNumber(powerLawFit.r_squared, 3)}</div>
                    </div>
                `;
            }

            let riskHtml = '';
            if (currentRisk) {
                riskHtml = `
                    <div class="stat-card" style="border-left: 3px solid ${currentRisk.color};">
                        <div class="stat-label">Risk Level</div>
                        <div class="stat-value" style="color: ${currentRisk.color};">${currentRisk.level}</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid ${currentRisk.color};">
                        <div class="stat-label">Deviation</div>
                        <div class="stat-value">${currentRisk.deviation >= 0 ? '+' : ''}${formatNumber(currentRisk.deviation, 2)}σ</div>
                    </div>
                `;
            }

            const html = `
                <div class="stat-card">
                    <div class="stat-label">Pair</div>
                    <div class="stat-value">${pairName}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Current Value</div>
                    <div class="stat-value">${formatNumber(stats.current, 4)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid ${stats.change >= 0 ? '#48bb78' : '#f56565'};">
                    <div class="stat-label">Change</div>
                    <div class="stat-value" style="color: ${stats.change >= 0 ? '#48bb78' : '#f56565'};">
                        ${stats.change >= 0 ? '+' : ''}${formatNumber(stats.change, 2)}%
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Average</div>
                    <div class="stat-value">${formatNumber(stats.mean, 4)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Maximum</div>
                    <div class="stat-value">${formatNumber(stats.max, 4)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Minimum</div>
                    <div class="stat-value">${formatNumber(stats.min, 4)}</div>
                </div>
                ${powerLawStatsHtml}
                ${riskHtml}
            `;

            statsDiv.innerHTML = html;
            statsDiv.style.display = 'grid';
        }

        function plotPairChart(aligned, ratios, numSymbol, denomSymbol, scale, normalize, powerLawFit) {
            const dates = aligned.dates.map(d => new Date(d));

            const pairName = `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]}`;

            const traces = [];

            // Calculate risk deviations for color coding
            let deviations = null;
            let currentRisk = null;

            if (powerLawFit && !normalize && !isNaN(powerLawFit.drift_annual)) {
                // Check if this uses Bitcoin logarithmic model
                const isBitcoinModel = powerLawFit.btc_model === 'logarithmic';
                const residualStd = powerLawFit.residual_std;

                if (isBitcoinModel) {
                    // Bitcoin logarithmic model: log(P(t)) = a*log(t-t0) + b
                    const a = powerLawFit.btc_params.a;
                    const b = powerLawFit.btc_params.b;
                    const t0 = powerLawFit.btc_params.t0;

                    // Calculate deviation for each point (in units of σ)
                    deviations = aligned.dates.map((dateStr, i) => {
                        const date = new Date(dateStr);
                        const t_unix = date.getTime() / 1000;  // Convert to Unix timestamp in seconds

                        if (t_unix <= t0 || ratios[i] <= 0) return 0; // Default to 0

                        const logR_fit = b + a * Math.log(t_unix - t0);
                        const logR_actual = Math.log(ratios[i]);
                        return (logR_actual - logR_fit) / residualStd; // In units of σ
                    });
                } else {
                    // Standard power law model: R(t) = R(0) * exp(μ*t)
                    const startDate = new Date(powerLawFit.start_date);
                    const mu = powerLawFit.drift_annual;
                    const R0 = powerLawFit.initial_value;
                    const logR0 = Math.log(R0);

                    // Calculate deviation for each point (in units of σ)
                    deviations = aligned.dates.map((dateStr, i) => {
                        const date = new Date(dateStr);
                        const t = (date - startDate) / (1000 * 60 * 60 * 24 * 365.25);

                        if (t < 0 || ratios[i] <= 0) return 0; // Default to 0

                        const logR_fit = logR0 + mu * t;
                        const logR_actual = Math.log(ratios[i]);
                        return (logR_actual - logR_fit) / residualStd; // In units of σ
                    });
                }

                // Calculate current risk
                if (deviations.length > 0) {
                    const deviation = deviations[deviations.length - 1];

                    currentRisk = {
                        deviation: deviation,
                        level: deviation < -2 ? 'Very Undervalued' :
                               deviation < -1 ? 'Undervalued' :
                               deviation < -0.5 ? 'Slightly Undervalued' :
                               deviation < 0.5 ? 'Fair Value' :
                               deviation < 1 ? 'Slightly Overvalued' :
                               deviation < 2 ? 'Overvalued' : 'Very Overvalued',
                        color: deviation < -2 ? '#7cb342' :
                               deviation < -1 ? '#9ccc65' :
                               deviation < -0.5 ? '#c5e1a5' :
                               deviation < 0.5 ? '#90a4ae' :
                               deviation < 1 ? '#ffb74d' :
                               deviation < 2 ? '#ff9800' : '#ef5350'
                    };
                }
            }

            // Main price ratio trace with color coding
            if (deviations) {
                // Use colorscale based on deviation from trend
                // Clamp to ±2σ for color scale
                const colorValues = deviations.map(d => Math.max(-2, Math.min(2, d)));

                traces.push({
                    x: dates,
                    y: ratios,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: pairName,
                    marker: {
                        size: 3,
                        color: colorValues,
                        colorscale: [
                            [0.0, '#7cb342'],   // -2σ: Muted green (very undervalued)
                            [0.25, '#9ccc65'],  // -1σ: Light green (undervalued)
                            [0.375, '#c5e1a5'], // -0.5σ: Pale green
                            [0.5, '#90a4ae'],   // 0σ: Blue-grey (fair value)
                            [0.625, '#ffb74d'], // +0.5σ: Soft orange
                            [0.75, '#ff9800'],  // +1σ: Orange (overvalued)
                            [1.0, '#ef5350']    // +2σ: Muted red (very overvalued)
                        ],
                        cmin: -2,
                        cmax: 2,
                        showscale: true,
                        colorbar: {
                            title: {
                                text: 'Risk (σ)',
                                side: 'right'
                            },
                            thickness: 15,
                            len: 0.7,
                            x: 1.02,
                            xanchor: 'left',
                            tickmode: 'array',
                            tickvals: [-2, -1, 0, 1, 2],
                            ticktext: ['-2σ<br>Very Under', '-1σ<br>Under', '0σ<br>Fair', '+1σ<br>Over', '+2σ<br>Very Over'],
                            tickfont: { size: 10 }
                        }
                    },
                    line: {
                        color: 'rgba(144, 164, 174, 0.3)',
                        width: 1
                    },
                    hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Ratio: %{y:.4f}<br>Deviation: %{marker.color:.2f}σ<extra></extra>'
                });
            } else {
                // Default single-color trace
                traces.push({
                    x: dates,
                    y: ratios,
                    type: 'scatter',
                    mode: 'lines',
                    name: pairName,
                    line: { color: '#667eea', width: 2 },
                    hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Ratio: %{y:.4f}<extra></extra>'
                });
            }

            // Add power law fit if available and not normalized
            if (powerLawFit && !normalize && !isNaN(powerLawFit.drift_annual)) {
                // Check if this uses Bitcoin logarithmic model
                const isBitcoinModel = powerLawFit.btc_model === 'logarithmic';

                const startDate = new Date(powerLawFit.start_date);
                const residualStd = powerLawFit.residual_std;  // Standard deviation in log space

                const fitDates = [];
                const fittedLine = [];
                const upperBand = [];
                const lowerBand = [];

                if (isBitcoinModel) {
                    // Bitcoin logarithmic model: log(P(t)) = a*log(t-t0) + b
                    const a = powerLawFit.btc_params.a;
                    const b = powerLawFit.btc_params.b;
                    const t0 = powerLawFit.btc_params.t0;

                    // Calculate for each date in the aligned data
                    aligned.dates.forEach(dateStr => {
                        const date = new Date(dateStr);
                        const t_unix = date.getTime() / 1000;  // Convert to Unix timestamp in seconds

                        if (t_unix > t0) {  // Only plot for dates > t0
                            const logR_fit = b + a * Math.log(t_unix - t0);

                            fitDates.push(date);
                            fittedLine.push(Math.exp(logR_fit));
                            // Constant parallel channel in log space
                            upperBand.push(Math.exp(logR_fit + residualStd));
                            lowerBand.push(Math.exp(logR_fit - residualStd));
                        }
                    });
                } else {
                    // Standard power law model: R(t) = R(0) * exp(μ*t)
                    // In log space: log(R(t)) = log(R0) + μ*t
                    const mu = powerLawFit.drift_annual;
                    const R0 = powerLawFit.initial_value;
                    const logR0 = Math.log(R0);

                    // Calculate for each date in the aligned data
                    aligned.dates.forEach(dateStr => {
                        const date = new Date(dateStr);
                        const t = (date - startDate) / (1000 * 60 * 60 * 24 * 365.25);  // years

                        if (t >= 0) {  // Only plot for dates >= start_date
                            const logR_fit = logR0 + mu * t;

                            fitDates.push(date);
                            fittedLine.push(Math.exp(logR_fit));
                            // Constant parallel channel in log space
                            upperBand.push(Math.exp(logR_fit + residualStd));
                            lowerBand.push(Math.exp(logR_fit - residualStd));
                        }
                    });
                }

                if (fitDates.length > 0) {
                    // Upper volatility band
                    traces.push({
                        x: fitDates,
                        y: upperBand,
                        type: 'scatter',
                        mode: 'lines',
                        name: '+1σ',
                        line: { color: 'rgba(246, 173, 85, 0.3)', width: 1, dash: 'dot' },
                        showlegend: true,
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>+1σ: %{y:.4f}<extra></extra>'
                    });

                    // Fitted trend line
                    traces.push({
                        x: fitDates,
                        y: fittedLine,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Power Law Fit (μ)',
                        line: { color: '#f6ad55', width: 2, dash: 'dash' },
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Fit: %{y:.4f}<extra></extra>'
                    });

                    // Lower volatility band
                    traces.push({
                        x: fitDates,
                        y: lowerBand,
                        type: 'scatter',
                        mode: 'lines',
                        name: '-1σ',
                        line: { color: 'rgba(246, 173, 85, 0.3)', width: 1, dash: 'dot' },
                        showlegend: true,
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>-1σ: %{y:.4f}<extra></extra>'
                    });
                }
            }

            const yAxisTitle = normalize ?
                `${pairName} (Base 100)` :
                `${pairName} Ratio`;

            const layout = {
                title: {
                    text: normalize ?
                        `${pairName} - Normalized to 100` :
                        `${pairName} - Price Ratio`,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Date',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)'
                },
                yaxis: {
                    title: yAxisTitle,
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    type: scale
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    x: 0.5,
                    xanchor: 'center',
                    y: -0.15,
                    yanchor: 'top',
                    bgcolor: 'rgba(0, 0, 0, 0.7)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                margin: { b: 100 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            document.getElementById('pairChartContainer').style.display = 'block';
            Plotly.newPlot('pairChart', traces, layout, config);

            return currentRisk;
        }

        // ============================================================================
        // Main Update Function
        // ============================================================================

        async function updatePairChart() {
            const numSymbol = document.getElementById('numeratorSelect').value;
            const denomSymbol = document.getElementById('denominatorSelect').value;
            const scale = document.getElementById('scaleSelect').value;
            const normalize = document.getElementById('normalizeCheck').checked;

            // Validate selection
            if (!numSymbol || !denomSymbol) {
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                hideError();
                return;
            }

            if (numSymbol === denomSymbol) {
                showError('Please select two different assets');
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                return;
            }

            try {
                hideError();
                showLoading();

                // Load data for both symbols
                const data1 = await loadMarketData(numSymbol);
                const data2 = await loadMarketData(denomSymbol);

                // Load power law fits
                const fits = await loadPowerLawFits();
                const pairKey = `${numSymbol}/${denomSymbol}`;
                const powerLawFit = fits ? fits[pairKey] : null;

                // Align data by common dates
                const aligned = alignDataByDate(data1, data2);

                if (aligned.dates.length === 0) {
                    throw new Error('No overlapping dates found between selected assets');
                }

                // Calculate pair ratio
                const ratios = calculatePairRatio(aligned, normalize);

                // Calculate statistics
                const stats = calculateStatistics(ratios);

                // Update display and get risk info
                const currentRisk = plotPairChart(aligned, ratios, numSymbol, denomSymbol, scale, normalize, powerLawFit);
                updateStats(stats, numSymbol, denomSymbol, normalize, powerLawFit, currentRisk);

                hideLoading();

            } catch (error) {
                console.error('Error updating pair chart:', error);
                showError('Error loading data: ' + error.message);
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                hideLoading();
            }
        }

        // ============================================================================
        // Event Listeners
        // ============================================================================

        document.getElementById('numeratorSelect').addEventListener('change', updatePairChart);
        document.getElementById('denominatorSelect').addEventListener('change', updatePairChart);
        document.getElementById('scaleSelect').addEventListener('change', updatePairChart);
        document.getElementById('normalizeCheck').addEventListener('change', updatePairChart);

        // Event listener for ratio metric selector
        document.getElementById('ratioMetricSelect').addEventListener('change', async () => {
            const symbols = ['sp500', 'nasdaq', 'vti', 'eem', 'gold', 'silver', 'palladium', 'copper', 'oil', 'tlt', 'btc', 'cpi', 'usd'];
            const symbolLabels = symbols.map(s => SYMBOL_NAMES[s]);
            await createRatioMetricsChart(symbols, symbolLabels);
        });

        // Event listener for scatter metric selector
        document.getElementById('scatterMetricSelect').addEventListener('change', async () => {
            const symbols = ['sp500', 'nasdaq', 'vti', 'eem', 'gold', 'silver', 'palladium', 'copper', 'oil', 'tlt', 'btc', 'cpi', 'usd'];
            const symbolLabels = symbols.map(s => SYMBOL_NAMES[s]);
            await createRiskReturnScatter(symbols, symbolLabels);
        });

        // ============================================================================
        // Risk Matrix
        // ============================================================================

        async function createRiskMatrix() {
            const fits = await loadPowerLawFits();
            if (!fits) {
                console.warn('No power law fits available for risk matrix');
                return;
            }

            const symbols = ['sp500', 'nasdaq', 'vti', 'eem', 'gold', 'silver', 'palladium', 'copper', 'oil', 'tlt', 'btc', 'cpi', 'usd'];
            const symbolLabels = symbols.map(s => SYMBOL_NAMES[s]);

            // Create matrix of risk values
            const riskMatrix = [];
            const textMatrix = [];

            for (let i = 0; i < symbols.length; i++) {
                const row = [];
                const textRow = [];

                for (let j = 0; j < symbols.length; j++) {
                    if (i === j) {
                        row.push(0);  // Diagonal is always 0 (same asset)
                        textRow.push('—');
                    } else {
                        const pairKey = `${symbols[i]}/${symbols[j]}`;
                        const fit = fits[pairKey];

                        if (fit && !isNaN(fit.drift_annual) && fit.residual_std) {
                            // Calculate current risk deviation
                            // We need the latest price data
                            const deviation = 0;  // Placeholder, will calculate later
                            row.push(deviation);
                            textRow.push(deviation.toFixed(2) + 'σ');
                        } else {
                            row.push(null);
                            textRow.push('N/A');
                        }
                    }
                }

                riskMatrix.push(row);
                textMatrix.push(textRow);
            }

            // Calculate actual current risks by loading latest data
            for (let i = 0; i < symbols.length; i++) {
                for (let j = 0; j < symbols.length; j++) {
                    if (i === j) continue;

                    const pairKey = `${symbols[i]}/${symbols[j]}`;
                    const fit = fits[pairKey];

                    if (fit && !isNaN(fit.drift_annual) && fit.residual_std) {
                        try {
                            const data1 = await loadMarketData(symbols[i]);
                            const data2 = await loadMarketData(symbols[j]);
                            const aligned = alignDataByDate(data1, data2);

                            if (aligned.dates.length > 0) {
                                const ratio = aligned.values1[aligned.values1.length - 1] /
                                             aligned.values2[aligned.values2.length - 1];

                                const lastDate = new Date(aligned.dates[aligned.dates.length - 1]);
                                let logR_fit;

                                // Check if this uses Bitcoin logarithmic model
                                if (fit.btc_model === 'logarithmic') {
                                    // Bitcoin logarithmic model: log(P(t)) = a*log(t-t0) + b
                                    const a = fit.btc_params.a;
                                    const b = fit.btc_params.b;
                                    const t0 = fit.btc_params.t0;
                                    const t_unix = lastDate.getTime() / 1000;

                                    logR_fit = b + a * Math.log(t_unix - t0);
                                } else {
                                    // Standard power law model
                                    const startDate = new Date(fit.start_date);
                                    const t = (lastDate - startDate) / (1000 * 60 * 60 * 24 * 365.25);
                                    logR_fit = Math.log(fit.initial_value) + fit.drift_annual * t;
                                }

                                const logR_actual = Math.log(ratio);
                                const deviation = (logR_actual - logR_fit) / fit.residual_std;

                                riskMatrix[i][j] = deviation;
                                textMatrix[i][j] = deviation.toFixed(2) + 'σ';
                            }
                        } catch (error) {
                            console.warn(`Could not calculate risk for ${pairKey}:`, error);
                        }
                    }
                }
            }

            // Create heatmap
            const trace = {
                z: riskMatrix,
                x: symbolLabels,
                y: symbolLabels,
                text: textMatrix,
                type: 'heatmap',
                colorscale: [
                    [0.0, '#7cb342'],   // -2σ: Muted green
                    [0.25, '#9ccc65'],  // -1σ: Light green
                    [0.375, '#c5e1a5'], // -0.5σ: Pale green
                    [0.5, '#90a4ae'],   // 0σ: Blue-grey (fair value)
                    [0.625, '#ffb74d'], // +0.5σ: Soft orange
                    [0.75, '#ff9800'],  // +1σ: Orange
                    [1.0, '#ef5350']    // +2σ: Muted red
                ],
                zmin: -2,
                zmax: 2,
                hovertemplate: '%{y} / %{x}<br>Risk: %{z:.2f}σ<extra></extra>',
                showscale: true,
                colorbar: {
                    title: 'Risk (σ)',
                    thickness: 15,
                    len: 0.7,
                    tickmode: 'array',
                    tickvals: [-2, -1, 0, 1, 2],
                    ticktext: ['-2σ Very Under', '-1σ Under', '0σ Fair', '+1σ Over', '+2σ Very Over']
                }
            };

            const layout = {
                title: {
                    text: 'Trading Pair Risk Matrix (Current Valuation)',
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Denominator',
                    color: '#a0a0a0',
                    side: 'bottom'
                },
                yaxis: {
                    title: 'Numerator',
                    color: '#a0a0a0',
                    autorange: 'reversed'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                margin: { l: 100, r: 100, t: 80, b: 100 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('riskMatrix', [trace], layout, config);

            // Create network graph based on risk matrix
            createNetworkGraph(riskMatrix, symbols, symbolLabels);

            // Calculate and display average risk per asset
            createAverageRiskChart(riskMatrix, symbols, symbolLabels);
        }

        function createNetworkGraph(riskMatrix, symbols, symbolLabels) {
            // Calculate node positions using MDS (Multidimensional Scaling) based on risk pattern similarity
            // Compute distance matrix: distance between two assets based on their risk pattern similarity
            const n = symbols.length;
            const distanceMatrix = [];

            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        row.push(0);
                    } else {
                        // Euclidean distance between risk patterns (rows of risk matrix)
                        let sumSq = 0;
                        for (let k = 0; k < n; k++) {
                            const val1 = riskMatrix[i][k] !== null ? riskMatrix[i][k] : 0;
                            const val2 = riskMatrix[j][k] !== null ? riskMatrix[j][k] : 0;
                            sumSq += Math.pow(val1 - val2, 2);
                        }
                        row.push(Math.sqrt(sumSq));
                    }
                }
                distanceMatrix.push(row);
            }

            // Simple MDS: use classical MDS (PCoA) to get 2D coordinates
            // For simplicity, we'll use a force-directed approach
            // Initialize random positions
            const positions = symbols.map(() => ({
                x: Math.random() * 10 - 5,
                y: Math.random() * 10 - 5
            }));

            // Run simple force-directed layout iterations
            const iterations = 100;
            const learningRate = 0.1;

            for (let iter = 0; iter < iterations; iter++) {
                for (let i = 0; i < n; i++) {
                    let fx = 0, fy = 0;

                    for (let j = 0; j < n; j++) {
                        if (i === j) continue;

                        const dx = positions[j].x - positions[i].x;
                        const dy = positions[j].y - positions[i].y;
                        const currentDist = Math.sqrt(dx * dx + dy * dy) + 0.01;
                        const targetDist = distanceMatrix[i][j];

                        // Spring force: attract if too far, repel if too close
                        const force = (currentDist - targetDist) * learningRate;

                        fx += force * (dx / currentDist);
                        fy += force * (dy / currentDist);
                    }

                    positions[i].x += fx;
                    positions[i].y += fy;
                }
            }

            // Create edge traces and arrowhead annotations
            // Edges will be rendered as traces (behind nodes), arrowheads as small annotations
            const traces = [];
            const arrowAnnotations = [];

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i === j) continue;

                    const riskValue = riskMatrix[i][j];
                    if (riskValue !== null && !isNaN(riskValue)) {
                        // Only draw edges for significant risk values
                        if (Math.abs(riskValue) > 0.5) {
                            // Determine direction based on risk:
                            // If riskValue < 0: asset i is undervalued relative to j -> arrow points from i to j
                            // If riskValue > 0: asset i is overvalued relative to j -> arrow points from j to i
                            let startX, startY, endX, endY;

                            if (riskValue < 0) {
                                // i is undervalued relative to j, arrow: i -> j
                                startX = positions[i].x;
                                startY = positions[i].y;
                                endX = positions[j].x;
                                endY = positions[j].y;
                            } else {
                                // i is overvalued relative to j, arrow: j -> i
                                startX = positions[j].x;
                                startY = positions[j].y;
                                endX = positions[i].x;
                                endY = positions[i].y;
                            }

                            // Color based on risk magnitude - use subtle gray
                            const absRisk = Math.abs(riskValue);
                            const opacity = Math.min(absRisk / 6, 0.25);  // Much lower opacity
                            const baseColor = '144, 164, 174';  // Always gray
                            const color = `rgba(${baseColor}, ${opacity})`;

                            // Add edge trace (line)
                            traces.push({
                                x: [startX, endX],
                                y: [startY, endY],
                                type: 'scatter',
                                mode: 'lines',
                                line: {
                                    color: color,
                                    width: Math.min(absRisk * 0.4, 1.2)  // Thinner lines
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });

                            // Add small arrowhead annotation
                            // Position it near the end but not overlapping the node
                            const dx = endX - startX;
                            const dy = endY - startY;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const arrowX = endX - (dx / length) * 0.5;  // 0.5 units before the node
                            const arrowY = endY - (dy / length) * 0.5;

                            arrowAnnotations.push({
                                x: arrowX,
                                y: arrowY,
                                ax: arrowX - (dx / length) * 0.3,
                                ay: arrowY - (dy / length) * 0.3,
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1,
                                arrowwidth: 1.5,
                                arrowcolor: color
                            });
                        }
                    }
                }
            }

            // Create node trace
            const nodeX = positions.map(p => p.x);
            const nodeY = positions.map(p => p.y);

            // Calculate node colors based on average risk (same as "Average Risk by Asset" chart)
            const nodeColors = symbols.map((_, i) => {
                let sum = 0, count = 0;
                for (let j = 0; j < n; j++) {
                    if (i !== j && riskMatrix[i][j] !== null && !isNaN(riskMatrix[i][j])) {
                        sum += riskMatrix[i][j];
                        count++;
                    }
                }
                return count > 0 ? sum / count : 0;
            });

            const nodeTrace = {
                x: nodeX,
                y: nodeY,
                text: symbolLabels,
                mode: 'markers+text',
                type: 'scatter',
                marker: {
                    size: 45,
                    color: nodeColors,
                    colorscale: [
                        [0.0, '#7cb342'],   // Undervalued
                        [0.25, '#9ccc65'],  // Slightly undervalued
                        [0.5, '#90a4ae'],   // Fair value
                        [0.75, '#ff9800'],  // Slightly overvalued
                        [1.0, '#ef5350']    // Overvalued
                    ],
                    cmin: -1.5,
                    cmax: 1.5,
                    showscale: true,
                    colorbar: {
                        title: 'Avg Risk (σ)',
                        thickness: 15,
                        len: 0.5,
                        x: 1.02,
                        xanchor: 'left'
                    },
                    line: {
                        color: '#ffffff',
                        width: 3
                    }
                },
                textposition: 'middle center',
                textfont: {
                    size: 10.5,
                    color: '#ffffff',
                    family: 'Arial, sans-serif',
                    weight: 'bold'
                },
                hovertemplate: '<b>%{text}</b><br>Avg Risk: %{marker.color:.2f}σ<extra></extra>'
            };

            // Add all edge traces first, then node trace (so nodes are on top)
            const allTraces = [...traces, nodeTrace];

            const layout = {
                title: {
                    text: 'Asset Relationship Network',
                    font: { color: '#e4e4e4', size: 18 }
                },
                showlegend: false,
                xaxis: {
                    showgrid: false,
                    zeroline: false,
                    showticklabels: false,
                    color: '#a0a0a0'
                },
                yaxis: {
                    showgrid: false,
                    zeroline: false,
                    showticklabels: false,
                    color: '#a0a0a0'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'closest',
                margin: { l: 40, r: 120, t: 80, b: 40 },
                annotations: arrowAnnotations
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('networkGraph', allTraces, layout, config);
        }

        async function createAverageRiskChart(riskMatrix, symbols, symbolLabels) {
            // Calculate average risk for each asset (average per row, excluding diagonal)
            const averageRisks = [];

            for (let i = 0; i < symbols.length; i++) {
                let sum = 0;
                let count = 0;

                for (let j = 0; j < symbols.length; j++) {
                    if (i !== j && riskMatrix[i][j] !== null && !isNaN(riskMatrix[i][j])) {
                        sum += riskMatrix[i][j];
                        count++;
                    }
                }

                averageRisks.push(count > 0 ? sum / count : 0);
            }

            // Create bar chart
            const trace = {
                x: symbolLabels,
                y: averageRisks,
                type: 'bar',
                marker: {
                    color: averageRisks.map(risk => {
                        // Use same color scheme as matrix
                        if (risk < -1.5) return '#7cb342';      // Very undervalued
                        if (risk < -0.75) return '#9ccc65';     // Undervalued
                        if (risk < -0.25) return '#c5e1a5';     // Slightly undervalued
                        if (risk < 0.25) return '#90a4ae';      // Fair value
                        if (risk < 0.75) return '#ffb74d';      // Slightly overvalued
                        if (risk < 1.5) return '#ff9800';       // Overvalued
                        return '#ef5350';                        // Very overvalued
                    }),
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 1
                    }
                },
                hovertemplate: '%{x}<br>Average Risk: %{y:.2f}σ<extra></extra>'
            };

            const layout = {
                title: {
                    text: 'Average Risk Across All Trading Pairs (per asset)',
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Asset',
                    color: '#a0a0a0',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Average Risk (σ)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 255, 255, 0.3)',
                    zerolinewidth: 2
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                margin: { l: 80, r: 40, t: 80, b: 120 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('averageRiskChart', [trace], layout, config);

            // Calculate and display average CAGR per asset
            createAverageCAGRChart(symbols, symbolLabels);
        }

        async function createAverageCAGRChart(symbols, symbolLabels) {
            const fits = await loadPowerLawFits();
            if (!fits) {
                console.warn('No power law fits available for CAGR chart');
                return;
            }

            // Calculate CAGR for each asset in USD terms (exclude Bitcoin - it destroys the scale)
            const cagrs = [];
            const filteredSymbols = [];
            const filteredLabels = [];

            for (let i = 0; i < symbols.length; i++) {
                // Skip Bitcoin for CAGR chart
                if (symbols[i] === 'btc') {
                    continue;
                }

                filteredSymbols.push(symbols[i]);
                filteredLabels.push(symbolLabels[i]);

                if (symbols[i] === 'usd') {
                    cagrs.push(0); // USD vs USD is always 0%
                } else {
                    const pairKey = `${symbols[i]}/usd`;
                    const fit = fits[pairKey];

                    if (fit && !isNaN(fit.drift_annual)) {
                        cagrs.push(fit.drift_annual * 100); // Convert to percentage
                    } else {
                        cagrs.push(0);
                    }
                }
            }

            // Create bar chart
            const trace = {
                x: filteredLabels,
                y: cagrs,
                type: 'bar',
                marker: {
                    color: filteredSymbols.map((symbol, i) => {
                        // Color CPI in red, others based on CAGR value
                        if (symbol === 'cpi') return '#ef5350';  // Red for CPI

                        const cagr = cagrs[i];
                        // Green for positive growth, pink for negative
                        if (cagr > 10) return '#48bb78';        // Strong positive
                        if (cagr > 5) return '#68d391';         // Good positive
                        if (cagr > 0) return '#9ae6b4';         // Mild positive
                        if (cagr > -5) return '#fbb6ce';        // Mild negative
                        if (cagr > -10) return '#f687b3';       // Negative
                        return '#ed64a6';                        // Strong negative
                    }),
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 1
                    }
                },
                hovertemplate: '%{x}<br>Average CAGR: %{y:.2f}%<extra></extra>'
            };

            const layout = {
                title: {
                    text: 'Annualized Growth Rate (CAGR) vs USD',
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Asset',
                    color: '#a0a0a0',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Average CAGR (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 255, 255, 0.3)',
                    zerolinewidth: 2
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                margin: { l: 80, r: 40, t: 80, b: 120 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('averageCAGRChart', [trace], layout, config);

            // Calculate and display ratio metrics
            createRatioMetricsChart(symbols, symbolLabels);
        }

        async function createRatioMetricsChart(symbols, symbolLabels) {
            const metricType = document.getElementById('ratioMetricSelect').value;

            // Update description
            const descriptionEl = document.getElementById('ratioDescription');
            if (metricType === 'sharpe') {
                descriptionEl.textContent = 'Sharpe Ratio: Measures risk-adjusted return using total volatility. Higher is better.';
            } else {
                descriptionEl.textContent = 'Sortino Ratio: Measures risk-adjusted return using downside volatility only. Higher is better.';
            }

            // Calculate ratios for each asset vs USD
            const ratios = [];
            const filteredSymbols = [];
            const filteredLabels = [];

            for (let i = 0; i < symbols.length; i++) {
                // Skip USD (can't calculate ratio vs itself) and CPI
                if (symbols[i] === 'usd' || symbols[i] === 'cpi') {
                    continue;
                }

                try {
                    const data = await loadMarketData(symbols[i]);

                    if (data.close && data.close.length > 1) {
                        const returns = calculateReturns(data.close);

                        // Determine periods per year based on data frequency
                        // Approximate from data timestamps
                        let periodsPerYear = 252; // Default to daily
                        if (data.timestamps && data.timestamps.length > 1) {
                            // Timestamps are in Unix seconds, not milliseconds
                            const avgDaysBetween = (data.timestamps[data.timestamps.length - 1] - data.timestamps[0]) /
                                                   (data.timestamps.length - 1) / (60 * 60 * 24);
                            if (avgDaysBetween > 25) {
                                periodsPerYear = 12; // Monthly data
                            } else if (avgDaysBetween > 5) {
                                periodsPerYear = 52; // Weekly data
                            }
                        }

                        let ratio;
                        if (metricType === 'sharpe') {
                            ratio = calculateSharpeRatio(returns, periodsPerYear);
                        } else {
                            ratio = calculateSortinoRatio(returns, periodsPerYear);
                        }

                        if (ratio !== null && !isNaN(ratio)) {
                            filteredSymbols.push(symbols[i]);
                            filteredLabels.push(symbolLabels[i]);
                            ratios.push(ratio);
                        }
                    }
                } catch (error) {
                    console.warn(`Could not calculate ${metricType} ratio for ${symbols[i]}:`, error);
                }
            }

            // Create bar chart
            const metricName = metricType === 'sharpe' ? 'Sharpe Ratio' : 'Sortino Ratio';

            const trace = {
                x: filteredLabels,
                y: ratios,
                type: 'bar',
                marker: {
                    color: ratios.map(ratio => {
                        // Color based on ratio value
                        // Sharpe/Sortino > 2 is excellent, > 1 is good, > 0 is okay, < 0 is bad
                        if (ratio > 2) return '#48bb78';        // Excellent (dark green)
                        if (ratio > 1) return '#68d391';        // Good (green)
                        if (ratio > 0.5) return '#9ae6b4';      // Above average (light green)
                        if (ratio > 0) return '#90a4ae';        // Okay (gray)
                        if (ratio > -0.5) return '#fbb6ce';     // Below average (light pink)
                        if (ratio > -1) return '#f687b3';       // Poor (pink)
                        return '#ed64a6';                        // Very poor (dark pink)
                    }),
                    line: {
                        color: 'rgba(255, 255, 255, 0.3)',
                        width: 1
                    }
                },
                hovertemplate: `%{x}<br>${metricName}: %{y:.2f}<extra></extra>`
            };

            const layout = {
                title: {
                    text: `${metricName} by Asset`,
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Asset',
                    color: '#a0a0a0',
                    tickangle: -45
                },
                yaxis: {
                    title: metricName,
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 255, 255, 0.3)',
                    zerolinewidth: 2
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                margin: { l: 80, r: 40, t: 80, b: 120 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('ratioMetricsChart', [trace], layout, config);

            // Create risk-return scatter plot
            createRiskReturnScatter(symbols, symbolLabels);
        }

        async function createRiskReturnScatter(symbols, symbolLabels) {
            const metricType = document.getElementById('scatterMetricSelect').value;

            // Calculate returns, volatility, and selected ratio for each asset
            const returns = [];
            const volatilities = [];
            const ratioValues = [];
            const labels = [];
            let bitcoinStats = null;

            for (let i = 0; i < symbols.length; i++) {
                // Skip USD (no return) and CPI
                if (symbols[i] === 'usd' || symbols[i] === 'cpi') {
                    continue;
                }

                // Calculate Bitcoin stats but don't add to plot
                if (symbols[i] === 'btc') {
                    try {
                        const data = await loadMarketData(symbols[i]);
                        if (data.close && data.close.length > 1) {
                            const assetReturns = calculateReturns(data.close);
                            let periodsPerYear = 252;
                            if (data.timestamps && data.timestamps.length > 1) {
                                // Timestamps are in Unix seconds, not milliseconds
                                const avgDaysBetween = (data.timestamps[data.timestamps.length - 1] - data.timestamps[0]) /
                                                       (data.timestamps.length - 1) / (60 * 60 * 24);
                                if (avgDaysBetween > 25) {
                                    periodsPerYear = 12;
                                } else if (avgDaysBetween > 5) {
                                    periodsPerYear = 52;
                                }
                            }
                            const meanReturn = assetReturns.reduce((a, b) => a + b, 0) / assetReturns.length;
                            const variance = assetReturns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / assetReturns.length;
                            const stdDev = Math.sqrt(variance);
                            const annualizedReturn = meanReturn * periodsPerYear * 100;
                            const annualizedVolatility = stdDev * Math.sqrt(periodsPerYear) * 100;
                            let ratio;
                            if (metricType === 'sharpe') {
                                ratio = calculateSharpeRatio(assetReturns, periodsPerYear);
                            } else {
                                ratio = calculateSortinoRatio(assetReturns, periodsPerYear);
                            }
                            bitcoinStats = {
                                return: annualizedReturn,
                                volatility: annualizedVolatility,
                                ratio: ratio
                            };
                        }
                    } catch (error) {
                        console.warn('Could not calculate Bitcoin metrics:', error);
                    }
                    continue;  // Skip adding to plot
                }

                try {
                    const data = await loadMarketData(symbols[i]);

                    if (data.close && data.close.length > 1) {
                        const assetReturns = calculateReturns(data.close);

                        // Determine periods per year based on data frequency
                        let periodsPerYear = 252; // Default to daily
                        if (data.timestamps && data.timestamps.length > 1) {
                            // Timestamps are in Unix seconds, not milliseconds
                            const avgDaysBetween = (data.timestamps[data.timestamps.length - 1] - data.timestamps[0]) /
                                                   (data.timestamps.length - 1) / (60 * 60 * 24);
                            if (avgDaysBetween > 25) {
                                periodsPerYear = 12; // Monthly data
                            } else if (avgDaysBetween > 5) {
                                periodsPerYear = 52; // Weekly data
                            }
                        }

                        // Calculate mean and standard deviation
                        const meanReturn = assetReturns.reduce((a, b) => a + b, 0) / assetReturns.length;
                        const variance = assetReturns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / assetReturns.length;
                        const stdDev = Math.sqrt(variance);

                        // Annualize
                        const annualizedReturn = meanReturn * periodsPerYear * 100; // Convert to percentage
                        const annualizedVolatility = stdDev * Math.sqrt(periodsPerYear) * 100; // Convert to percentage

                        // Calculate selected ratio
                        let ratio;
                        if (metricType === 'sharpe') {
                            ratio = calculateSharpeRatio(assetReturns, periodsPerYear);
                        } else {
                            ratio = calculateSortinoRatio(assetReturns, periodsPerYear);
                        }

                        if (!isNaN(annualizedReturn) && !isNaN(annualizedVolatility) && ratio !== null) {
                            returns.push(annualizedReturn);
                            volatilities.push(annualizedVolatility);
                            ratioValues.push(ratio);
                            labels.push(symbolLabels[i]);
                        }
                    }
                } catch (error) {
                    console.warn(`Could not calculate metrics for ${symbols[i]}:`, error);
                }
            }

            // Create scatter plot
            const metricName = metricType === 'sharpe' ? 'Sharpe Ratio' : 'Sortino Ratio';

            // Update description with Bitcoin stats if available
            const descriptionEl = document.getElementById('scatterDescription');
            let descriptionText = '';
            if (metricType === 'sharpe') {
                descriptionText = 'Annualized return vs annualized volatility. Color indicates Sharpe ratio (darker green = better risk-adjusted returns).';
            } else {
                descriptionText = 'Annualized return vs annualized volatility. Color indicates Sortino ratio (darker green = better risk-adjusted returns).';
            }

            if (bitcoinStats) {
                descriptionText += ` Bitcoin excluded from plot (Return: ${bitcoinStats.return.toFixed(1)}%, Volatility: ${bitcoinStats.volatility.toFixed(1)}%, ${metricName}: ${bitcoinStats.ratio.toFixed(2)}) to maintain readable scale.`;
            }
            descriptionEl.textContent = descriptionText;

            const trace = {
                x: volatilities,
                y: returns,
                text: labels,
                mode: 'markers+text',
                type: 'scatter',
                marker: {
                    size: 12,  // Uniform size for all bubbles
                    color: ratioValues,
                    colorscale: [
                        [0.0, '#ef5350'],   // Low Sharpe (red)
                        [0.2, '#ff9800'],   // Below average (orange)
                        [0.4, '#ffb74d'],   // Average (light orange)
                        [0.6, '#90a4ae'],   // Neutral (gray)
                        [0.8, '#9ae6b4'],   // Good (light green)
                        [1.0, '#48bb78']    // Excellent (dark green)
                    ],
                    showscale: true,
                    colorbar: {
                        title: {
                            text: metricType === 'sharpe' ? 'Sharpe<br>Ratio' : 'Sortino<br>Ratio',
                            side: 'right'
                        },
                        thickness: 15,
                        len: 0.7,
                        x: 1.02,
                        xanchor: 'left'
                    },
                    line: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        width: 1
                    }
                },
                textposition: 'top center',
                textfont: {
                    size: 10,
                    color: '#e4e4e4'
                },
                hovertemplate: '<b>%{text}</b><br>' +
                               'Return: %{y:.2f}%<br>' +
                               'Volatility: %{x:.2f}%<br>' +
                               metricName + ': %{marker.color:.2f}<extra></extra>'
            };

            const layout = {
                title: {
                    text: 'Risk-Return Scatter Plot',
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Annualized Volatility (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 255, 255, 0.3)',
                    zerolinewidth: 2
                },
                yaxis: {
                    title: 'Annualized Return (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(255, 255, 255, 0.3)',
                    zerolinewidth: 2
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'closest',
                margin: { l: 80, r: 120, t: 80, b: 80 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('riskReturnScatter', [trace], layout, config);
        }

        // ============================================================================
        // Return Distribution
        // ============================================================================

        async function createReturnDistribution() {
            const symbol = document.getElementById('distributionAssetSelect').value;

            try {
                const data = await loadMarketData(symbol);

                if (!data.close || data.close.length < 2) {
                    console.warn(`Not enough data for ${symbol}`);
                    return;
                }

                // Calculate weekly returns (normalized to 7-day periods)
                const returns = [];

                // First, determine if we have timestamps to work with
                if (!data.timestamps || data.timestamps.length === 0) {
                    console.warn(`${symbol}: No timestamp data available`);
                    return;
                }

                // Strategy: Sample data points that are approximately 7 days apart
                const WEEK_SECONDS = 7 * 24 * 60 * 60;  // 7 days in seconds
                const TOLERANCE = 3 * 24 * 60 * 60;  // ±3 days tolerance (in seconds)

                let lastSampleTime = data.timestamps[0];
                let lastSamplePrice = data.close[0];

                for (let i = 1; i < data.timestamps.length; i++) {
                    const currentTime = data.timestamps[i];
                    const timeDiff = currentTime - lastSampleTime;  // Difference in seconds

                    // Check if we're approximately a week away (7 days ± 3 days tolerance)
                    if (timeDiff >= WEEK_SECONDS - TOLERANCE && timeDiff <= WEEK_SECONDS + TOLERANCE) {
                        // Calculate weekly log return
                        if (data.close[i] > 0 && lastSamplePrice > 0) {
                            const weeklyReturn = Math.log(data.close[i] / lastSamplePrice);
                            returns.push(weeklyReturn * 100); // Convert to percentage
                        }

                        // Update last sample
                        lastSampleTime = currentTime;
                        lastSamplePrice = data.close[i];
                    } else if (timeDiff > WEEK_SECONDS + TOLERANCE) {
                        // If we've gone too far past a week, force a sample
                        // This handles cases where data is sparse
                        if (data.close[i] > 0 && lastSamplePrice > 0) {
                            // Normalize the return to weekly equivalent
                            const actualReturn = Math.log(data.close[i] / lastSamplePrice);
                            const weeklyNormalized = actualReturn * (WEEK_SECONDS / timeDiff);
                            returns.push(weeklyNormalized * 100); // Convert to percentage
                        }

                        // Update last sample
                        lastSampleTime = currentTime;
                        lastSamplePrice = data.close[i];
                    }
                }

                console.log(`${symbol}: Calculated ${returns.length} weekly returns from ${data.close.length} prices`);

                // Calculate percentiles to focus on main distribution (exclude outliers)
                const sortedReturns = [...returns].sort((a, b) => a - b);
                const p1 = sortedReturns[Math.floor(returns.length * 0.01)];   // 1st percentile
                const p99 = sortedReturns[Math.floor(returns.length * 0.99)];  // 99th percentile

                // Expand range slightly for better visualization
                const range = p99 - p1;
                const xMin = p1 - range * 0.1;
                const xMax = p99 + range * 0.1;

                console.log(`${symbol}: Focusing histogram on range [${xMin.toFixed(2)}%, ${xMax.toFixed(2)}%] (1st-99th percentile)`);

                const totalCount = returns.length;

                // Manually calculate bin counts for hover display
                const binSize = (xMax - xMin) / 60;
                const binCounts = new Array(60).fill(0);
                const binCenters = [];

                // Calculate bin centers
                for (let i = 0; i < 60; i++) {
                    binCenters.push(xMin + (i + 0.5) * binSize);
                }

                // Count returns in each bin
                returns.forEach(ret => {
                    const binIndex = Math.floor((ret - xMin) / binSize);
                    if (binIndex >= 0 && binIndex < 60) {
                        binCounts[binIndex]++;
                    }
                });

                // Create histogram with custom data for proper hover labels
                const trace = {
                    x: returns,
                    type: 'histogram',
                    name: 'Returns',
                    histnorm: 'probability',
                    nbinsx: 60,
                    xbins: {
                        start: xMin,
                        end: xMax,
                        size: binSize
                    },
                    marker: {
                        color: '#667eea',
                        line: {
                            color: 'rgba(255, 255, 255, 0.3)',
                            width: 1
                        }
                    },
                    customdata: binCounts,
                    hovertemplate: '<b>Return Range:</b> %{x}%<br>' +
                                   '<b>Probability:</b> %{y:.4f}<br>' +
                                   '<b>Count:</b> %{customdata}<br>' +
                                   '<extra></extra>'
                };

                const layout = {
                    title: {
                        text: `${SYMBOL_NAMES[symbol]} - Return Distribution`,
                        font: { color: '#e4e4e4', size: 18 }
                    },
                    xaxis: {
                        title: 'Weekly Return (%)',
                        color: '#a0a0a0',
                        gridcolor: 'rgba(255, 255, 255, 0.1)',
                        zeroline: true,
                        zerolinecolor: 'rgba(255, 255, 255, 0.5)',
                        zerolinewidth: 2,
                        range: [xMin, xMax]
                    },
                    yaxis: {
                        title: 'Probability',
                        color: '#a0a0a0',
                        gridcolor: 'rgba(255, 255, 255, 0.1)'
                    },
                    plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                    paper_bgcolor: 'rgba(0, 0, 0, 0)',
                    font: { color: '#e4e4e4' },
                    showlegend: false,
                    margin: { l: 80, r: 40, t: 80, b: 80 }
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false
                };

                Plotly.newPlot('returnDistributionChart', [trace], layout, config);

            } catch (error) {
                console.error(`Error creating return distribution for ${symbol}:`, error);
            }
        }

        // ============================================================================
        // Initialization
        // ============================================================================

        // Set default selection and load initial chart
        window.addEventListener('load', async () => {
            // Create risk matrix first
            await createRiskMatrix();

            // Default: SP500/USD
            document.getElementById('numeratorSelect').value = 'sp500';
            document.getElementById('denominatorSelect').value = 'usd';
            updatePairChart();

            // Create return distribution
            createReturnDistribution();
        });

        // Event listener for distribution asset selector
        document.getElementById('distributionAssetSelect').addEventListener('change', createReturnDistribution);
    </script>
</body>
</html>

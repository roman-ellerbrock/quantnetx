<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implied Probability Distribution</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e4e4e4;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            color: #a0a0a0;
            font-size: 0.9rem;
            font-weight: 500;
        }

        select, input {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            color: #e4e4e4;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover, input:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #667eea;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #a0a0a0;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #f44336;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #a0a0a0;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ“ˆ Implied Probability Distribution</h1>
            <p class="subtitle">Risk-Neutral Probability from Options Prices</p>
        </header>

        <div class="info-box" id="methodInfo">
            <strong>Method:</strong> <span id="methodDescription">Implied probabilities are calculated using the second derivative of option prices (butterfly spread approach).
            The probability density at each strike is computed using finite differences for non-uniformly spaced strikes, then normalized to sum to 1.</span>
            Both call and put distributions are shown for comparison. They should theoretically match but may differ due to market microstructure, liquidity, and bid-ask spreads.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="currencySelect">Currency</label>
                <select id="currencySelect">
                    <option value="BTC">BTC</option>
                    <option value="ETH">ETH</option>
                </select>
            </div>
            <div class="control-group">
                <label for="expirySelect">Expiry Date</label>
                <select id="expirySelect">
                    <option value="">Loading expiries...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="methodSelect">Calculation Method</label>
                <select id="methodSelect">
                    <option value="finite-diff">Finite Differences (Breeden-Litzenberger)</option>
                    <option value="cubic-spline">Cubic Spline Interpolation</option>
                </select>
            </div>
            <div class="control-group">
                <button id="refreshBtn">Refresh Data</button>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="stats" class="stats-grid" style="display: none;"></div>

        <div id="loading" class="loading" style="display: none;">Loading data...</div>

        <div class="chart-container" id="chartContainer" style="display: none;">
            <div id="probabilityChart"></div>
        </div>

        <div class="chart-container" id="cumulativeChartContainer" style="display: none;">
            <div id="cumulativeChart"></div>
        </div>

        <div class="chart-container" id="markPriceChartContainer" style="display: none;">
            <div style="margin-bottom: 15px;">
                <label for="derivativeSelect" style="margin-right: 10px;">Display:</label>
                <select id="derivativeSelect">
                    <option value="price">Mark Price</option>
                    <option value="first">First Derivative (Delta)</option>
                    <option value="second">Second Derivative (Gamma)</option>
                </select>
            </div>
            <div id="markPriceChart"></div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Global Variables
        // ============================================================================
        let allData = [];
        let availableExpiries = [];
        const DERIBIT_API_BASE = 'https://www.deribit.com/api/v2/public';

        // ============================================================================
        // Date and Time Utilities
        // ============================================================================

        // Parse expiry date string to timestamp
        function parseExpiryToTimestamp(expiryStr) {
            // Format: DDMMMYY (e.g., "14OCT25")
            const day = parseInt(expiryStr.substr(0, 2));
            const monthStr = expiryStr.substr(2, 3).toUpperCase();
            const year = 2000 + parseInt(expiryStr.substr(5, 2));

            const months = {
                'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,
                'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11
            };

            const month = months[monthStr];
            if (month === undefined) return null;

            // Deribit options expire at 8:00 UTC
            const date = new Date(Date.UTC(year, month, day, 8, 0, 0));
            return date.getTime();
        }

        // ============================================================================
        // API Data Fetching
        // ============================================================================

        // Fetch available expiry dates from Deribit
        async function fetchAvailableExpiries(currency = 'BTC') {
            try {
                const response = await fetch(`${DERIBIT_API_BASE}/get_book_summary_by_currency?currency=${currency}&kind=option`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch instruments: ${response.statusText}`);
                }

                const data = await response.json();
                const instruments = data.result || [];

                // Extract unique expiry dates and calculate timestamps
                const expiryMap = new Map();
                instruments.forEach(instrument => {
                    const match = instrument.instrument_name.match(/\w+-(\w+)-\d+-[CP]/);
                    if (match) {
                        const expiryStr = match[1];
                        if (!expiryMap.has(expiryStr)) {
                            const timestamp = parseExpiryToTimestamp(expiryStr);
                            if (timestamp) {
                                expiryMap.set(expiryStr, timestamp);
                            }
                        }
                    }
                });

                return Array.from(expiryMap.entries())
                    .map(([expiry, timestamp]) => ({ expiry, timestamp }))
                    .sort((a, b) => a.timestamp - b.timestamp);
            } catch (error) {
                showError('Error fetching expiries: ' + error.message);
                return [];
            }
        }

        // Fetch option chain data from Deribit for a specific expiry
        async function fetchOptionChainData(currency = 'BTC', expiry) {
            try {
                const response = await fetch(`${DERIBIT_API_BASE}/get_book_summary_by_currency?currency=${currency}&kind=option`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.statusText}`);
                }

                const data = await response.json();
                const instruments = data.result || [];

                // Filter instruments by expiry
                const filteredInstruments = instruments.filter(instrument =>
                    instrument.instrument_name.includes(expiry)
                );

                // Transform to our data format
                const timestamp = new Date().toISOString();
                const transformedData = filteredInstruments.map(instrument => {
                    // Parse instrument name: BTC-14OCT25-80000-C
                    const match = instrument.instrument_name.match(/(\w+)-(\w+)-(\d+)-([CP])/);
                    if (!match) return null;

                    const [_, underlying, expiryDate, strike, optionType] = match;

                    return {
                        timestamp: timestamp,
                        instrument_name: instrument.instrument_name,
                        underlying: underlying,
                        expiry: expiryDate,
                        strike: parseFloat(strike),
                        option_type: optionType,
                        underlying_price: instrument.underlying_price,
                        underlying_index: instrument.underlying_index,
                        mark_price: instrument.mark_price,
                        mark_iv: instrument.mark_iv,
                        bid_price: instrument.bid_price,
                        ask_price: instrument.ask_price,
                        mid_price: instrument.mid_price,
                        last_price: instrument.last,
                        open_interest: instrument.open_interest,
                        volume: instrument.volume,
                        expiration_timestamp: parseExpiryToTimestamp(expiryDate)
                    };
                }).filter(item => item !== null);

                return transformedData;
            } catch (error) {
                showError('Error fetching option chain: ' + error.message);
                return [];
            }
        }

        // ============================================================================
        // Probability Calculation Functions
        // ============================================================================

        // ============================================================================
        // Cubic Spline Helper Functions
        // ============================================================================

        // Natural cubic spline implementation
        function cubicSpline(x, y) {
            const n = x.length - 1;
            const a = [...y];
            const b = new Array(n);
            const c = new Array(n + 1).fill(0);
            const d = new Array(n);
            const h = new Array(n);
            const alpha = new Array(n);
            const l = new Array(n + 1).fill(1);
            const mu = new Array(n + 1).fill(0);
            const z = new Array(n + 1).fill(0);

            // Calculate h values
            for (let i = 0; i < n; i++) {
                h[i] = x[i + 1] - x[i];
            }

            // Calculate alpha values
            for (let i = 1; i < n; i++) {
                alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1]);
            }

            // Solve tridiagonal system
            for (let i = 1; i < n; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }

            // Back substitution
            for (let j = n - 1; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }

            return { a, b, c, d, x };
        }

        // Evaluate cubic spline at a point
        function evalSpline(spline, xVal) {
            const { a, b, c, d, x } = spline;

            // Find the interval
            let i = 0;
            for (i = 0; i < x.length - 1; i++) {
                if (xVal <= x[i + 1]) break;
            }
            if (i >= a.length) i = a.length - 1;

            const dx = xVal - x[i];
            return a[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
        }

        // Evaluate second derivative of cubic spline
        function evalSplineSecondDerivative(spline, xVal) {
            const { c, d, x } = spline;

            // Find the interval
            let i = 0;
            for (i = 0; i < x.length - 1; i++) {
                if (xVal <= x[i + 1]) break;
            }
            if (i >= c.length) i = c.length - 1;

            const dx = xVal - x[i];
            return 2 * c[i] + 6 * d[i] * dx;
        }

        // ============================================================================
        // Method 1: Finite Differences (Breeden-Litzenberger) - Original Method
        // ============================================================================

        // Calculate probabilities from options using second derivative
        function calculateProbabilitiesFromOptions(options, underlyingPrice, method = 'finite-diff') {
            if (options.length < 3) {
                return [];
            }

            const probabilities = [];

            if (method === 'finite-diff') {
                // Original finite difference method
                for (let i = 1; i < options.length - 1; i++) {
                    const xa = options[i - 1].strike;
                    const xb = options[i].strike;
                    const xc = options[i + 1].strike;

                    const fa = options[i - 1].mark_price;
                    const fb = options[i].mark_price;
                    const fc = options[i + 1].mark_price;

                    const d1 = xb - xa;
                    const d2 = xc - xb;

                    if (d1 <= 0 || d2 <= 0) continue;

                    // Second derivative for non-uniformly spaced points
                    const secondDerivative = 2 * (fa * d2 + fc * d1 - fb * (d1 + d2)) / (d1 * d2 * (d1 + d2));

                    if (secondDerivative > 0) {
                        probabilities.push({
                            strike: xb,
                            probability: secondDerivative,
                            iv: options[i].mark_iv
                        });
                    }
                }
            } else if (method === 'cubic-spline') {
                // Cubic spline interpolation method
                const strikes = options.map(o => o.strike);
                const prices = options.map(o => o.mark_price);

                // Create cubic spline
                const spline = cubicSpline(strikes, prices);

                // Generate dense grid of strikes
                const minStrike = strikes[0];
                const maxStrike = strikes[strikes.length - 1];
                const numPoints = Math.max(100, strikes.length * 10);
                const strikeStep = (maxStrike - minStrike) / numPoints;

                for (let k = minStrike; k <= maxStrike - strikeStep; k += strikeStep) {
                    const secondDeriv = evalSplineSecondDerivative(spline, k);

                    if (secondDeriv > 0) {
                        // Find closest option for IV
                        const closestOption = options.reduce((prev, curr) =>
                            Math.abs(curr.strike - k) < Math.abs(prev.strike - k) ? curr : prev
                        );

                        probabilities.push({
                            strike: k,
                            probability: secondDeriv,
                            iv: closestOption.mark_iv
                        });
                    }
                }
            }

            if (probabilities.length === 0) {
                return [];
            }

            // Normalize so the distribution integrates to 1
            const totalProb = probabilities.reduce((sum, p) => sum + p.probability, 0);
            if (totalProb > 0) {
                probabilities.forEach(p => {
                    p.probability = p.probability / totalProb;
                });
            }

            return probabilities;
        }

        // Calculate implied probability distribution from both calls and puts
        function calculateImpliedProbability(optionsData, method = 'finite-diff') {
            // Filter and sort calls and puts
            const calls = optionsData
                .filter(d => d.option_type === 'C' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const puts = optionsData
                .filter(d => d.option_type === 'P' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            if (calls.length < 3 && puts.length < 3) {
                throw new Error('Insufficient data for probability calculation (need at least 3 call or put options)');
            }

            // Get underlying price
            const underlyingPrice = calls.length > 0 ? calls[0].underlying_price : puts[0].underlying_price;

            // Calculate time to expiry
            const expirationTimestamp = calls.length > 0 ? calls[0].expiration_timestamp : puts[0].expiration_timestamp;
            const now = Date.now();
            const timeToExpiry = (expirationTimestamp - now) / (1000 * 60 * 60 * 24 * 365);

            if (timeToExpiry <= 0) {
                throw new Error('Options have expired');
            }

            // Calculate probabilities from calls and puts
            let callProbabilities = calls.length >= 3 ?
                calculateProbabilitiesFromOptions(calls, underlyingPrice, method) : [];

            let putProbabilities = puts.length >= 3 ?
                calculateProbabilitiesFromOptions(puts, underlyingPrice, method) : [];

            if (callProbabilities.length === 0 && putProbabilities.length === 0) {
                throw new Error('No valid probabilities calculated from calls or puts');
            }

            const expiryDate = calls.length > 0 ? calls[0].expiry : puts[0].expiry;

            return {
                callProbabilities: callProbabilities,
                putProbabilities: putProbabilities,
                underlyingPrice: underlyingPrice,
                timeToExpiry: timeToExpiry,
                expiryDate: expiryDate
            };
        }

        // Calculate cumulative distribution
        function calculateCumulativeDistribution(probabilities) {
            const cumulative = [];
            let sum = 0;

            for (const p of probabilities) {
                sum += p.probability;
                cumulative.push({
                    strike: p.strike,
                    cumulative: sum
                });
            }

            return cumulative;
        }

        // ============================================================================
        // Derivative Calculation Functions (for visualization)
        // ============================================================================

        // Calculate first derivative (delta) using central differences
        function calculateFirstDerivative(options) {
            const derivatives = [];

            for (let i = 1; i < options.length - 1; i++) {
                const xa = options[i - 1].strike;
                const xb = options[i].strike;
                const xc = options[i + 1].strike;

                const fa = options[i - 1].mark_price;
                const fb = options[i].mark_price;
                const fc = options[i + 1].mark_price;

                const d1 = xb - xa;
                const d2 = xc - xb;

                if (d1 <= 0 || d2 <= 0) continue;

                // First derivative using non-uniform spacing
                const firstDeriv = (fc - fa) / (d1 + d2) + (d2 - d1) * (fc - 2*fb + fa) / ((d1 + d2) * d1 * d2);

                derivatives.push({
                    strike: xb,
                    value: firstDeriv
                });
            }

            return derivatives;
        }

        // Calculate second derivative (gamma) for non-uniform spacing
        function calculateSecondDerivative(options) {
            const derivatives = [];

            for (let i = 1; i < options.length - 1; i++) {
                const xa = options[i - 1].strike;
                const xb = options[i].strike;
                const xc = options[i + 1].strike;

                const fa = options[i - 1].mark_price;
                const fb = options[i].mark_price;
                const fc = options[i + 1].mark_price;

                const d1 = xb - xa;
                const d2 = xc - xb;

                if (d1 <= 0 || d2 <= 0) continue;

                // Second derivative for non-equally spaced points
                const secondDeriv = 2 * (fa * d2 + fc * d1 - fb * (d1 + d2)) / (d1 * d2 * (d1 + d2));

                derivatives.push({
                    strike: xb,
                    value: secondDeriv
                });
            }

            return derivatives;
        }

        // ============================================================================
        // UI Utility Functions
        // ============================================================================

        // Format number
        function formatNumber(num, decimals = 2) {
            if (!num || num === '') return '-';
            const n = parseFloat(num);
            if (isNaN(n)) return '-';
            return n.toLocaleString('en-US', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            });
        }

        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Hide error
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        // Helper to calculate stats from probabilities
        function calcStats(probs, underlyingPrice) {
            if (probs.length === 0) return null;

            const expectedPrice = probs.reduce((sum, p) => sum + p.strike * p.probability, 0);
            const variance = probs.reduce((sum, p) => sum + Math.pow(p.strike - expectedPrice, 2) * p.probability, 0);
            const stdDev = Math.sqrt(variance);
            const mode = probs.reduce((max, p) => p.probability > max.probability ? p : max, probs[0]);
            const probAbove = probs.filter(p => p.strike > underlyingPrice).reduce((sum, p) => sum + p.probability, 0);
            const probBelow = probs.filter(p => p.strike <= underlyingPrice).reduce((sum, p) => sum + p.probability, 0);

            return { expectedPrice, stdDev, mode, probAbove, probBelow };
        }

        // ============================================================================
        // UI Update Functions
        // ============================================================================

        // Update stats display
        function updateStats(result) {
            const statsDiv = document.getElementById('stats');

            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];

            if (callProbs.length === 0 && putProbs.length === 0) {
                statsDiv.style.display = 'none';
                return;
            }

            const underlyingPrice = result.underlyingPrice;
            const callStats = calcStats(callProbs, underlyingPrice);
            const putStats = calcStats(putProbs, underlyingPrice);

            let html = `
                <div class="stat-card">
                    <div class="stat-label">Current Price</div>
                    <div class="stat-value">$${formatNumber(underlyingPrice, 2)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Time to Expiry</div>
                    <div class="stat-value">${(result.timeToExpiry * 365).toFixed(0)} days</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Expiry Date</div>
                    <div class="stat-value">${result.expiryDate}</div>
                </div>
            `;

            if (callStats) {
                html += `
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Expected Price (Calls)</div>
                    <div class="stat-value">$${formatNumber(callStats.expectedPrice, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Std Dev (Calls)</div>
                    <div class="stat-value">$${formatNumber(callStats.stdDev, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Prob Above (Calls)</div>
                    <div class="stat-value">${(callStats.probAbove * 100).toFixed(1)}%</div>
                </div>
                `;
            }

            if (putStats) {
                html += `
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Expected Price (Puts)</div>
                    <div class="stat-value">$${formatNumber(putStats.expectedPrice, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Std Dev (Puts)</div>
                    <div class="stat-value">$${formatNumber(putStats.stdDev, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Prob Below (Puts)</div>
                    <div class="stat-value">${(putStats.probBelow * 100).toFixed(1)}%</div>
                </div>
                `;
            }

            statsDiv.innerHTML = html;
            statsDiv.style.display = 'grid';
        }

        // ============================================================================
        // Plotting Functions
        // ============================================================================

        // Plot probability distribution
        function plotProbabilityDistribution(result) {
            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];
            const underlyingPrice = result.underlyingPrice;

            const traces = [];

            if (callProbs.length > 0) {
                traces.push({
                    x: callProbs.map(p => p.strike),
                    y: callProbs.map(p => p.probability * 100),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'From Calls',
                    line: {
                        color: '#667eea',
                        width: 3
                    },
                    marker: {
                        size: 6,
                        color: '#667eea'
                    },
                    fill: 'tozeroy',
                    fillcolor: 'rgba(102, 126, 234, 0.15)'
                });
            }

            if (putProbs.length > 0) {
                traces.push({
                    x: putProbs.map(p => p.strike),
                    y: putProbs.map(p => p.probability * 100),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'From Puts',
                    line: {
                        color: '#ff6b9d',
                        width: 3,
                        dash: 'dot'
                    },
                    marker: {
                        size: 6,
                        color: '#ff6b9d',
                        symbol: 'square'
                    },
                    fill: 'tozeroy',
                    fillcolor: 'rgba(255, 107, 157, 0.15)'
                });
            }

            const layout = {
                title: {
                    text: 'Implied Probability Distribution',
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: 'Probability Density (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '.2f'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }],
                annotations: [{
                    x: underlyingPrice,
                    y: 1,
                    yref: 'paper',
                    text: `Current: $${formatNumber(underlyingPrice, 0)}`,
                    showarrow: false,
                    font: { color: '#ffc107', size: 12 },
                    yanchor: 'bottom'
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('probabilityChart', traces, layout, config);
            document.getElementById('chartContainer').style.display = 'block';
        }

        // Plot cumulative distribution
        function plotCumulativeDistribution(result) {
            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];
            const underlyingPrice = result.underlyingPrice;

            const traces = [];

            if (callProbs.length > 0) {
                const callCumulative = calculateCumulativeDistribution(callProbs);
                traces.push({
                    x: callCumulative.map(c => c.strike),
                    y: callCumulative.map(c => c.cumulative * 100),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'From Calls',
                    line: {
                        color: '#667eea',
                        width: 3
                    }
                });
            }

            if (putProbs.length > 0) {
                const putCumulative = calculateCumulativeDistribution(putProbs);
                traces.push({
                    x: putCumulative.map(c => c.strike),
                    y: putCumulative.map(c => c.cumulative * 100),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'From Puts',
                    line: {
                        color: '#ff6b9d',
                        width: 3,
                        dash: 'dot'
                    }
                });
            }

            const layout = {
                title: {
                    text: 'Cumulative Distribution Function',
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: 'Cumulative Probability (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    range: [0, 100]
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 0,
                    yanchor: 'bottom',
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 100,
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('cumulativeChart', traces, layout, config);
            document.getElementById('cumulativeChartContainer').style.display = 'block';
        }

        // Plot mark prices, first derivative, or second derivative
        function plotMarkPrices(optionsData, underlyingPrice) {
            const displayMode = document.getElementById('derivativeSelect').value;

            const calls = optionsData
                .filter(d => d.option_type === 'C' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const puts = optionsData
                .filter(d => d.option_type === 'P' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const traces = [];
            let yAxisTitle = 'Mark Price';
            let chartTitle = 'Option Mark Prices';
            let yAxisFormat = '.4f';

            if (displayMode === 'price') {
                // Display mark prices
                yAxisTitle = 'Mark Price';
                chartTitle = 'Option Mark Prices';

                if (calls.length > 0) {
                    traces.push({
                        x: calls.map(c => c.strike),
                        y: calls.map(c => c.mark_price),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call Mark Prices',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length > 0) {
                    traces.push({
                        x: puts.map(p => p.strike),
                        y: puts.map(p => p.mark_price),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put Mark Prices',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            } else if (displayMode === 'first') {
                // Display first derivative (delta)
                yAxisTitle = 'First Derivative (dC/dK)';
                chartTitle = 'First Derivative of Option Prices';
                yAxisFormat = '.6f';

                if (calls.length >= 3) {
                    const callDerivs = calculateFirstDerivative(calls);
                    traces.push({
                        x: callDerivs.map(d => d.strike),
                        y: callDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call First Derivative',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length >= 3) {
                    const putDerivs = calculateFirstDerivative(puts);
                    traces.push({
                        x: putDerivs.map(d => d.strike),
                        y: putDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put First Derivative',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            } else if (displayMode === 'second') {
                // Display second derivative (gamma)
                yAxisTitle = 'Second Derivative (dÂ²C/dKÂ²)';
                chartTitle = 'Second Derivative of Option Prices';
                yAxisFormat = '.8f';

                if (calls.length >= 3) {
                    const callDerivs = calculateSecondDerivative(calls);
                    traces.push({
                        x: callDerivs.map(d => d.strike),
                        y: callDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call Second Derivative',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length >= 3) {
                    const putDerivs = calculateSecondDerivative(puts);
                    traces.push({
                        x: putDerivs.map(d => d.strike),
                        y: putDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put Second Derivative',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            }

            const layout = {
                title: {
                    text: chartTitle,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: yAxisTitle,
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: yAxisFormat
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }],
                annotations: [{
                    x: underlyingPrice,
                    y: 1,
                    yref: 'paper',
                    text: `Current: $${formatNumber(underlyingPrice, 0)}`,
                    showarrow: false,
                    font: { color: '#ffc107', size: 12 },
                    yanchor: 'bottom'
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('markPriceChart', traces, layout, config);
            document.getElementById('markPriceChartContainer').style.display = 'block';
        }

        // ============================================================================
        // Event Handlers
        // ============================================================================

        // Update method description based on selected method
        function updateMethodDescription() {
            const method = document.getElementById('methodSelect').value;
            const descriptionSpan = document.getElementById('methodDescription');

            const descriptions = {
                'finite-diff': 'Implied probabilities are calculated using the Breeden-Litzenberger formula: the second derivative of option prices with respect to strike. Uses finite differences for non-uniformly spaced strikes.',
                'cubic-spline': 'Uses cubic spline interpolation to create a smooth function through option prices, then computes the second derivative analytically. Provides smoother distributions with more data points.'
            };

            descriptionSpan.textContent = descriptions[method] || descriptions['finite-diff'];
        }

        // Handle expiry selection - fetch data and calculate probabilities
        async function handleExpiryChange() {
            const selectedExpiry = document.getElementById('expirySelect').value;
            const selectedCurrency = document.getElementById('currencySelect').value;
            const selectedMethod = document.getElementById('methodSelect').value;

            if (!selectedExpiry) {
                document.getElementById('chartContainer').style.display = 'none';
                document.getElementById('cumulativeChartContainer').style.display = 'none';
                document.getElementById('markPriceChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('loading').style.display = 'block';
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('cumulativeChartContainer').style.display = 'none';
            document.getElementById('markPriceChartContainer').style.display = 'none';
            document.getElementById('stats').style.display = 'none';

            try {
                // Fetch data from Deribit
                allData = await fetchOptionChainData(selectedCurrency, selectedExpiry);

                if (allData.length === 0) {
                    throw new Error('No data available for the selected expiry');
                }

                // Calculate implied probabilities using selected method
                const result = calculateImpliedProbability(allData, selectedMethod);

                if (result.callProbabilities.length === 0 && result.putProbabilities.length === 0) {
                    throw new Error('Unable to calculate probabilities (insufficient valid data)');
                }

                // Update UI
                updateStats(result);
                plotProbabilityDistribution(result);
                plotCumulativeDistribution(result);
                plotMarkPrices(allData, result.underlyingPrice);

            } catch (error) {
                showError(error.message);
            }

            document.getElementById('loading').style.display = 'none';
        }

        // Load available expiries from Deribit
        async function loadExpiries() {
            const currency = document.getElementById('currencySelect').value;
            const expirySelect = document.getElementById('expirySelect');

            hideError();
            expirySelect.innerHTML = '<option value="">Loading expiries...</option>';
            expirySelect.disabled = true;

            const expiries = await fetchAvailableExpiries(currency);

            if (expiries.length > 0) {
                expirySelect.innerHTML = '<option value="">Select an expiry...</option>';
                expiries.forEach(({ expiry, timestamp }) => {
                    const option = document.createElement('option');
                    option.value = expiry;
                    const daysToExpiry = Math.floor((timestamp - Date.now()) / (1000 * 60 * 60 * 24));
                    option.textContent = `${expiry} (${daysToExpiry}d)`;
                    expirySelect.appendChild(option);
                });
                availableExpiries = expiries;

                // Auto-select first expiry
                expirySelect.value = expiries[0].expiry;
                handleExpiryChange();
            } else {
                expirySelect.innerHTML = '<option value="">No expiries available</option>';
                showError('Failed to load expiries from Deribit');
            }

            expirySelect.disabled = false;
        }

        // ============================================================================
        // Event Listeners Setup
        // ============================================================================

        // Currency change - reset and reload expiries
        document.getElementById('currencySelect').addEventListener('change', () => {
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('cumulativeChartContainer').style.display = 'none';
            document.getElementById('markPriceChartContainer').style.display = 'none';
            document.getElementById('stats').style.display = 'none';
            loadExpiries();
        });

        // Expiry change - recalculate probabilities
        document.getElementById('expirySelect').addEventListener('change', handleExpiryChange);

        // Method change - update description and recalculate
        document.getElementById('methodSelect').addEventListener('change', () => {
            updateMethodDescription();
            const selectedExpiry = document.getElementById('expirySelect').value;
            if (selectedExpiry) {
                handleExpiryChange();
            }
        });

        // Derivative display mode change - update chart
        document.getElementById('derivativeSelect').addEventListener('change', () => {
            if (allData.length > 0) {
                const underlyingPrice = allData[0].underlying_price;
                plotMarkPrices(allData, underlyingPrice);
            }
        });

        // Refresh button - reload current data
        document.getElementById('refreshBtn').addEventListener('click', () => {
            const selectedExpiry = document.getElementById('expirySelect').value;
            if (selectedExpiry) {
                handleExpiryChange();
            } else {
                loadExpiries();
            }
        });

        // ============================================================================
        // Initialization
        // ============================================================================

        // Initialize on page load
        updateMethodDescription();
        loadExpiries();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantNetX - Market Pairs</title>
    <link rel="icon" type="image/png" href="assets/quantnetx_minilogo.png">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-title">
                <img src="assets/quantnetx_minilogo.png" alt="QuantNetX" class="minilogo">
                <h1>QuantNetX</h1>
            </div>
            <p class="subtitle">Market Pairs Analysis</p>
        </header>

        <nav class="nav-bar">
            <a href="index.html" class="nav-link">Options Analysis</a>
            <a href="bitcoin_risk.html" class="nav-link">Bitcoin Risk Metric</a>
            <a href="market_pairs.html" class="nav-link active">Market Pairs</a>
        </nav>

        <div class="info-box">
            <strong>Market Pairs Analysis:</strong> Compare relative performance between different assets.
            Select two symbols to create a trading pair ratio chart (e.g., BTC/Gold, SP500/NASDAQ).
            The chart shows the ratio of the first asset divided by the second asset over time.
            <br><br>
            <strong>Power Law Model:</strong> R(t) = R(0) · exp(μ·t), where μ is the exponential growth rate (annualized).
            The dashed orange line shows the fitted exponential trend with ±1σ parallel bands.
            <br><br>
            <strong>Risk Color Coding:</strong> The price markers are colored based on deviation from the power law trend.
            Green = undervalued (below trend), Blue = fair value (near trend), Orange/Red = overvalued (above trend).
            See the color scale legend on the chart for exact σ values.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="numeratorSelect">Numerator</label>
                <select id="numeratorSelect">
                    <option value="">Select asset...</option>
                    <option value="btc" selected>Bitcoin (BTC)</option>
                    <option value="sp500">S&P 500</option>
                    <option value="nasdaq">NASDAQ</option>
                    <option value="gold">Gold</option>
                    <option value="copper">Copper</option>
                    <option value="oil">Oil (WTI)</option>
                    <option value="tlt">TLT (20Y Treasury)</option>
                    <option value="usd">USD (Cash)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="denominatorSelect">Denominator</label>
                <select id="denominatorSelect">
                    <option value="">Select asset...</option>
                    <option value="btc">Bitcoin (BTC)</option>
                    <option value="sp500">S&P 500</option>
                    <option value="nasdaq">NASDAQ</option>
                    <option value="gold">Gold</option>
                    <option value="copper">Copper</option>
                    <option value="oil">Oil (WTI)</option>
                    <option value="tlt">TLT (20Y Treasury)</option>
                    <option value="usd" selected>USD (Cash)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="scaleSelect">Scale</label>
                <select id="scaleSelect">
                    <option value="linear">Linear</option>
                    <option value="log" selected>Logarithmic</option>
                </select>
            </div>
            <div class="control-group">
                <label for="normalizeCheck">
                    <input type="checkbox" id="normalizeCheck"> Normalize to 100
                </label>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">Loading data...</div>
        <div id="stats" class="stats-grid" style="display: none;"></div>

        <div class="chart-container" id="pairChartContainer" style="display: none;">
            <div id="pairChart" style="width: 100%; height: 600px;"></div>
        </div>

        <div class="chart-container" id="riskMatrixContainer">
            <h3 style="color: #e4e4e4; margin-bottom: 15px;">Risk Matrix - Current Valuation of All Pairs</h3>
            <div id="riskMatrix" style="width: 100%; height: 700px;"></div>
        </div>
    </div>

    <script>
        // Market data cache
        const marketData = {};
        let powerLawFits = null;  // Power law fits cache

        const SYMBOL_NAMES = {
            'btc': 'Bitcoin',
            'sp500': 'S&P 500',
            'nasdaq': 'NASDAQ',
            'gold': 'Gold',
            'copper': 'Copper',
            'oil': 'Oil (WTI)',
            'tlt': 'TLT',
            'usd': 'USD'
        };

        // ============================================================================
        // Utility Functions
        // ============================================================================

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function formatNumber(num, decimals = 2) {
            if (!num || num === '' || isNaN(num)) return '-';
            return parseFloat(num).toLocaleString('en-US', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            });
        }

        // ============================================================================
        // Data Loading
        // ============================================================================

        async function loadPowerLawFits() {
            if (powerLawFits) {
                return powerLawFits;
            }

            try {
                const response = await fetch('../data/power_law_fits.json');
                if (!response.ok) {
                    console.warn('Power law fits not available');
                    return null;
                }

                const data = await response.json();
                powerLawFits = data.fits;
                return powerLawFits;
            } catch (error) {
                console.warn('Could not load power law fits:', error);
                return null;
            }
        }

        async function loadMarketData(symbol) {
            // Return cached data if available
            if (marketData[symbol]) {
                return marketData[symbol];
            }

            // USD is always 1.0
            if (symbol === 'usd') {
                marketData['usd'] = { constant: true, value: 1.0 };
                return marketData['usd'];
            }

            try {
                const response = await fetch(`../data/market_data/${symbol}_1d.csv`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${symbol} data: HTTP ${response.status}`);
                }

                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');

                const data = {
                    dates: [],
                    timestamps: [],
                    open: [],
                    high: [],
                    low: [],
                    close: [],
                    volume: []
                };

                // Parse CSV data
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length >= 7) {
                        data.dates.push(values[0]);
                        data.timestamps.push(parseInt(values[1]));
                        data.open.push(parseFloat(values[2]));
                        data.high.push(parseFloat(values[3]));
                        data.low.push(parseFloat(values[4]));
                        data.close.push(parseFloat(values[5]));
                        data.volume.push(parseFloat(values[6]));
                    }
                }

                marketData[symbol] = data;
                return data;

            } catch (error) {
                console.error(`Error loading ${symbol} data from ../data/market_data/${symbol}_1d.csv:`, error);
                throw new Error(`Failed to load ${symbol}: ${error.message}`);
            }
        }

        // ============================================================================
        // Data Processing
        // ============================================================================

        function alignDataByDate(data1, data2) {
            // For USD constant value
            if (data1.constant) {
                return {
                    dates: data2.dates,
                    timestamps: data2.timestamps,
                    values1: Array(data2.dates.length).fill(1.0),
                    values2: data2.close
                };
            }
            if (data2.constant) {
                return {
                    dates: data1.dates,
                    timestamps: data1.timestamps,
                    values1: data1.close,
                    values2: Array(data1.dates.length).fill(1.0)
                };
            }

            // Find common dates
            const dates1Set = new Set(data1.dates);
            const dates2Map = {};

            data2.dates.forEach((date, i) => {
                dates2Map[date] = i;
            });

            const aligned = {
                dates: [],
                timestamps: [],
                values1: [],
                values2: []
            };

            data1.dates.forEach((date, i) => {
                if (dates2Map.hasOwnProperty(date)) {
                    const j = dates2Map[date];
                    aligned.dates.push(date);
                    aligned.timestamps.push(data1.timestamps[i]);
                    aligned.values1.push(data1.close[i]);
                    aligned.values2.push(data2.close[j]);
                }
            });

            return aligned;
        }

        function calculatePairRatio(aligned, normalize = false) {
            const ratios = aligned.values1.map((v1, i) => v1 / aligned.values2[i]);

            if (normalize && ratios.length > 0) {
                const firstRatio = ratios[0];
                return ratios.map(r => (r / firstRatio) * 100);
            }

            return ratios;
        }

        function calculateStatistics(ratios) {
            if (ratios.length === 0) return null;

            const current = ratios[ratios.length - 1];
            const start = ratios[0];
            const change = ((current - start) / start) * 100;
            const max = Math.max(...ratios);
            const min = Math.min(...ratios);
            const mean = ratios.reduce((a, b) => a + b, 0) / ratios.length;

            return { current, start, change, max, min, mean };
        }

        // ============================================================================
        // Visualization
        // ============================================================================

        function updateStats(stats, numSymbol, denomSymbol, normalize, powerLawFit, currentRisk) {
            const statsDiv = document.getElementById('stats');

            const pairName = normalize ?
                `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]} (Normalized)` :
                `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]}`;

            let powerLawStatsHtml = '';
            if (powerLawFit && !isNaN(powerLawFit.drift_annual) && !isNaN(powerLawFit.volatility_annual)) {
                powerLawStatsHtml = `
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">Annualized Growth Rate</div>
                        <div class="stat-value">${powerLawFit.drift_annual >= 0 ? '+' : ''}${formatNumber(powerLawFit.drift_annual * 100, 2)}%</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">Annualized Volatility</div>
                        <div class="stat-value">${formatNumber(powerLawFit.volatility_annual * 100, 2)}%</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid #f6ad55;">
                        <div class="stat-label">R²</div>
                        <div class="stat-value">${formatNumber(powerLawFit.r_squared, 3)}</div>
                    </div>
                `;
            }

            let riskHtml = '';
            if (currentRisk) {
                riskHtml = `
                    <div class="stat-card" style="border-left: 3px solid ${currentRisk.color};">
                        <div class="stat-label">Risk Level</div>
                        <div class="stat-value" style="color: ${currentRisk.color};">${currentRisk.level}</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid ${currentRisk.color};">
                        <div class="stat-label">Deviation</div>
                        <div class="stat-value">${currentRisk.deviation >= 0 ? '+' : ''}${formatNumber(currentRisk.deviation, 2)}σ</div>
                    </div>
                `;
            }

            const html = `
                <div class="stat-card">
                    <div class="stat-label">Pair</div>
                    <div class="stat-value" style="font-size: 1.1em;">${pairName}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Current Value</div>
                    <div class="stat-value">${formatNumber(stats.current, 4)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid ${stats.change >= 0 ? '#48bb78' : '#f56565'};">
                    <div class="stat-label">Change</div>
                    <div class="stat-value" style="color: ${stats.change >= 0 ? '#48bb78' : '#f56565'};">
                        ${stats.change >= 0 ? '+' : ''}${formatNumber(stats.change, 2)}%
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Average</div>
                    <div class="stat-value">${formatNumber(stats.mean, 4)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Maximum</div>
                    <div class="stat-value">${formatNumber(stats.max, 4)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Minimum</div>
                    <div class="stat-value">${formatNumber(stats.min, 4)}</div>
                </div>
                ${powerLawStatsHtml}
                ${riskHtml}
            `;

            statsDiv.innerHTML = html;
            statsDiv.style.display = 'grid';
        }

        function plotPairChart(aligned, ratios, numSymbol, denomSymbol, scale, normalize, powerLawFit) {
            const dates = aligned.dates.map(d => new Date(d));

            const pairName = `${SYMBOL_NAMES[numSymbol]}/${SYMBOL_NAMES[denomSymbol]}`;

            const traces = [];

            // Calculate risk deviations for color coding
            let deviations = null;
            let currentRisk = null;

            if (powerLawFit && !normalize && !isNaN(powerLawFit.drift_annual)) {
                const startDate = new Date(powerLawFit.start_date);
                const mu = powerLawFit.drift_annual;
                const residualStd = powerLawFit.residual_std;
                const R0 = powerLawFit.initial_value;
                const logR0 = Math.log(R0);

                // Calculate deviation for each point (in units of σ)
                deviations = aligned.dates.map((dateStr, i) => {
                    const date = new Date(dateStr);
                    const t = (date - startDate) / (1000 * 60 * 60 * 24 * 365.25);

                    if (t < 0 || ratios[i] <= 0) return 0; // Default to 0

                    const logR_fit = logR0 + mu * t;
                    const logR_actual = Math.log(ratios[i]);
                    return (logR_actual - logR_fit) / residualStd; // In units of σ
                });

                // Calculate current risk
                if (deviations.length > 0) {
                    const deviation = deviations[deviations.length - 1];

                    currentRisk = {
                        deviation: deviation,
                        level: deviation < -2 ? 'Very Undervalued' :
                               deviation < -1 ? 'Undervalued' :
                               deviation < -0.5 ? 'Slightly Undervalued' :
                               deviation < 0.5 ? 'Fair Value' :
                               deviation < 1 ? 'Slightly Overvalued' :
                               deviation < 2 ? 'Overvalued' : 'Very Overvalued',
                        color: deviation < -2 ? '#7cb342' :
                               deviation < -1 ? '#9ccc65' :
                               deviation < -0.5 ? '#c5e1a5' :
                               deviation < 0.5 ? '#90a4ae' :
                               deviation < 1 ? '#ffb74d' :
                               deviation < 2 ? '#ff9800' : '#ef5350'
                    };
                }
            }

            // Main price ratio trace with color coding
            if (deviations) {
                // Use colorscale based on deviation from trend
                // Clamp to ±2σ for color scale
                const colorValues = deviations.map(d => Math.max(-2, Math.min(2, d)));

                traces.push({
                    x: dates,
                    y: ratios,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: pairName,
                    marker: {
                        size: 3,
                        color: colorValues,
                        colorscale: [
                            [0.0, '#7cb342'],   // -2σ: Muted green (very undervalued)
                            [0.25, '#9ccc65'],  // -1σ: Light green (undervalued)
                            [0.375, '#c5e1a5'], // -0.5σ: Pale green
                            [0.5, '#90a4ae'],   // 0σ: Blue-grey (fair value)
                            [0.625, '#ffb74d'], // +0.5σ: Soft orange
                            [0.75, '#ff9800'],  // +1σ: Orange (overvalued)
                            [1.0, '#ef5350']    // +2σ: Muted red (very overvalued)
                        ],
                        cmin: -2,
                        cmax: 2,
                        showscale: true,
                        colorbar: {
                            title: {
                                text: 'Risk (σ)',
                                side: 'right'
                            },
                            thickness: 15,
                            len: 0.7,
                            x: 1.02,
                            xanchor: 'left',
                            tickmode: 'array',
                            tickvals: [-2, -1, 0, 1, 2],
                            ticktext: ['-2σ<br>Very Under', '-1σ<br>Under', '0σ<br>Fair', '+1σ<br>Over', '+2σ<br>Very Over'],
                            tickfont: { size: 10 }
                        }
                    },
                    line: {
                        color: 'rgba(144, 164, 174, 0.3)',
                        width: 1
                    },
                    hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Ratio: %{y:.4f}<br>Deviation: %{marker.color:.2f}σ<extra></extra>'
                });
            } else {
                // Default single-color trace
                traces.push({
                    x: dates,
                    y: ratios,
                    type: 'scatter',
                    mode: 'lines',
                    name: pairName,
                    line: { color: '#667eea', width: 2 },
                    hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Ratio: %{y:.4f}<extra></extra>'
                });
            }

            // Add power law fit if available and not normalized
            if (powerLawFit && !normalize && !isNaN(powerLawFit.drift_annual)) {
                // Calculate fitted line from parameters
                // Model: R(t) = R(0) * exp(μ*t)
                // In log space: log(R(t)) = log(R0) + μ*t
                // Parallel bands: exp(log(R_fit) ± residual_std)

                const startDate = new Date(powerLawFit.start_date);
                const mu = powerLawFit.drift_annual;
                const residualStd = powerLawFit.residual_std;  // Standard deviation in log space
                const R0 = powerLawFit.initial_value;
                const logR0 = Math.log(R0);

                const fitDates = [];
                const fittedLine = [];
                const upperBand = [];
                const lowerBand = [];

                // Calculate for each date in the aligned data
                aligned.dates.forEach(dateStr => {
                    const date = new Date(dateStr);
                    const t = (date - startDate) / (1000 * 60 * 60 * 24 * 365.25);  // years

                    if (t >= 0) {  // Only plot for dates >= start_date
                        const logR_fit = logR0 + mu * t;

                        fitDates.push(date);
                        fittedLine.push(Math.exp(logR_fit));
                        // Constant parallel channel in log space
                        upperBand.push(Math.exp(logR_fit + residualStd));
                        lowerBand.push(Math.exp(logR_fit - residualStd));
                    }
                });

                if (fitDates.length > 0) {
                    // Upper volatility band
                    traces.push({
                        x: fitDates,
                        y: upperBand,
                        type: 'scatter',
                        mode: 'lines',
                        name: '+1σ',
                        line: { color: 'rgba(246, 173, 85, 0.3)', width: 1, dash: 'dot' },
                        showlegend: true,
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>+1σ: %{y:.4f}<extra></extra>'
                    });

                    // Fitted trend line
                    traces.push({
                        x: fitDates,
                        y: fittedLine,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Power Law Fit (μ)',
                        line: { color: '#f6ad55', width: 2, dash: 'dash' },
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>Fit: %{y:.4f}<extra></extra>'
                    });

                    // Lower volatility band
                    traces.push({
                        x: fitDates,
                        y: lowerBand,
                        type: 'scatter',
                        mode: 'lines',
                        name: '-1σ',
                        line: { color: 'rgba(246, 173, 85, 0.3)', width: 1, dash: 'dot' },
                        showlegend: true,
                        hovertemplate: 'Date: %{x|%Y-%m-%d}<br>-1σ: %{y:.4f}<extra></extra>'
                    });
                }
            }

            const yAxisTitle = normalize ?
                `${pairName} (Base 100)` :
                `${pairName} Ratio`;

            const layout = {
                title: {
                    text: normalize ?
                        `${pairName} - Normalized to 100` :
                        `${pairName} - Price Ratio`,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Date',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)'
                },
                yaxis: {
                    title: yAxisTitle,
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    type: scale
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    x: 0.5,
                    xanchor: 'center',
                    y: -0.15,
                    yanchor: 'top',
                    bgcolor: 'rgba(0, 0, 0, 0.7)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                margin: { b: 100 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            document.getElementById('pairChartContainer').style.display = 'block';
            Plotly.newPlot('pairChart', traces, layout, config);

            return currentRisk;
        }

        // ============================================================================
        // Main Update Function
        // ============================================================================

        async function updatePairChart() {
            const numSymbol = document.getElementById('numeratorSelect').value;
            const denomSymbol = document.getElementById('denominatorSelect').value;
            const scale = document.getElementById('scaleSelect').value;
            const normalize = document.getElementById('normalizeCheck').checked;

            // Validate selection
            if (!numSymbol || !denomSymbol) {
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                hideError();
                return;
            }

            if (numSymbol === denomSymbol) {
                showError('Please select two different assets');
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                return;
            }

            try {
                hideError();
                showLoading();

                // Load data for both symbols
                const data1 = await loadMarketData(numSymbol);
                const data2 = await loadMarketData(denomSymbol);

                // Load power law fits
                const fits = await loadPowerLawFits();
                const pairKey = `${numSymbol}/${denomSymbol}`;
                const powerLawFit = fits ? fits[pairKey] : null;

                // Align data by common dates
                const aligned = alignDataByDate(data1, data2);

                if (aligned.dates.length === 0) {
                    throw new Error('No overlapping dates found between selected assets');
                }

                // Calculate pair ratio
                const ratios = calculatePairRatio(aligned, normalize);

                // Calculate statistics
                const stats = calculateStatistics(ratios);

                // Update display and get risk info
                const currentRisk = plotPairChart(aligned, ratios, numSymbol, denomSymbol, scale, normalize, powerLawFit);
                updateStats(stats, numSymbol, denomSymbol, normalize, powerLawFit, currentRisk);

                hideLoading();

            } catch (error) {
                console.error('Error updating pair chart:', error);
                showError('Error loading data: ' + error.message);
                document.getElementById('pairChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                hideLoading();
            }
        }

        // ============================================================================
        // Event Listeners
        // ============================================================================

        document.getElementById('numeratorSelect').addEventListener('change', updatePairChart);
        document.getElementById('denominatorSelect').addEventListener('change', updatePairChart);
        document.getElementById('scaleSelect').addEventListener('change', updatePairChart);
        document.getElementById('normalizeCheck').addEventListener('change', updatePairChart);

        // ============================================================================
        // Risk Matrix
        // ============================================================================

        async function createRiskMatrix() {
            const fits = await loadPowerLawFits();
            if (!fits) {
                console.warn('No power law fits available for risk matrix');
                return;
            }

            const symbols = ['btc', 'sp500', 'nasdaq', 'gold', 'copper', 'oil', 'tlt', 'usd'];
            const symbolLabels = symbols.map(s => SYMBOL_NAMES[s]);

            // Create matrix of risk values
            const riskMatrix = [];
            const textMatrix = [];

            for (let i = 0; i < symbols.length; i++) {
                const row = [];
                const textRow = [];

                for (let j = 0; j < symbols.length; j++) {
                    if (i === j) {
                        row.push(0);  // Diagonal is always 0 (same asset)
                        textRow.push('—');
                    } else {
                        const pairKey = `${symbols[i]}/${symbols[j]}`;
                        const fit = fits[pairKey];

                        if (fit && !isNaN(fit.drift_annual) && fit.residual_std) {
                            // Calculate current risk deviation
                            // We need the latest price data
                            const deviation = 0;  // Placeholder, will calculate later
                            row.push(deviation);
                            textRow.push(deviation.toFixed(2) + 'σ');
                        } else {
                            row.push(null);
                            textRow.push('N/A');
                        }
                    }
                }

                riskMatrix.push(row);
                textMatrix.push(textRow);
            }

            // Calculate actual current risks by loading latest data
            for (let i = 0; i < symbols.length; i++) {
                for (let j = 0; j < symbols.length; j++) {
                    if (i === j) continue;

                    const pairKey = `${symbols[i]}/${symbols[j]}`;
                    const fit = fits[pairKey];

                    if (fit && !isNaN(fit.drift_annual) && fit.residual_std) {
                        try {
                            const data1 = await loadMarketData(symbols[i]);
                            const data2 = await loadMarketData(symbols[j]);
                            const aligned = alignDataByDate(data1, data2);

                            if (aligned.dates.length > 0) {
                                const ratio = aligned.values1[aligned.values1.length - 1] /
                                             aligned.values2[aligned.values2.length - 1];

                                const lastDate = new Date(aligned.dates[aligned.dates.length - 1]);
                                const startDate = new Date(fit.start_date);
                                const t = (lastDate - startDate) / (1000 * 60 * 60 * 24 * 365.25);

                                const logR_fit = Math.log(fit.initial_value) + fit.drift_annual * t;
                                const logR_actual = Math.log(ratio);
                                const deviation = (logR_actual - logR_fit) / fit.residual_std;

                                riskMatrix[i][j] = deviation;
                                textMatrix[i][j] = deviation.toFixed(2) + 'σ';
                            }
                        } catch (error) {
                            console.warn(`Could not calculate risk for ${pairKey}:`, error);
                        }
                    }
                }
            }

            // Create heatmap
            const trace = {
                z: riskMatrix,
                x: symbolLabels,
                y: symbolLabels,
                text: textMatrix,
                type: 'heatmap',
                colorscale: [
                    [0.0, '#7cb342'],   // -2σ: Muted green
                    [0.25, '#9ccc65'],  // -1σ: Light green
                    [0.375, '#c5e1a5'], // -0.5σ: Pale green
                    [0.5, '#90a4ae'],   // 0σ: Blue-grey (fair value)
                    [0.625, '#ffb74d'], // +0.5σ: Soft orange
                    [0.75, '#ff9800'],  // +1σ: Orange
                    [1.0, '#ef5350']    // +2σ: Muted red
                ],
                zmin: -2,
                zmax: 2,
                hovertemplate: '%{y} / %{x}<br>Risk: %{z:.2f}σ<extra></extra>',
                showscale: true,
                colorbar: {
                    title: 'Risk (σ)',
                    thickness: 15,
                    len: 0.7,
                    tickmode: 'array',
                    tickvals: [-2, -1, 0, 1, 2],
                    ticktext: ['-2σ Very Under', '-1σ Under', '0σ Fair', '+1σ Over', '+2σ Very Over']
                }
            };

            const layout = {
                title: {
                    text: 'Trading Pair Risk Matrix (Current Valuation)',
                    font: { color: '#e4e4e4', size: 18 }
                },
                xaxis: {
                    title: 'Denominator',
                    color: '#a0a0a0',
                    side: 'bottom'
                },
                yaxis: {
                    title: 'Numerator',
                    color: '#a0a0a0',
                    autorange: 'reversed'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                margin: { l: 100, r: 100, t: 80, b: 100 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('riskMatrix', [trace], layout, config);
        }

        // ============================================================================
        // Initialization
        // ============================================================================

        // Set default selection and load initial chart
        window.addEventListener('load', async () => {
            // Create risk matrix first
            await createRiskMatrix();

            // Default: BTC/USD
            document.getElementById('numeratorSelect').value = 'btc';
            document.getElementById('denominatorSelect').value = 'usd';
            updatePairChart();
        });
    </script>
</body>
</html>

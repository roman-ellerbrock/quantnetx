<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantNetX - Implied Probability Distribution</title>
    <link rel="icon" type="image/png" href="assets/quantnetx_minilogo.png">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-title">
                <img src="assets/quantnetx_minilogo.png" alt="QuantNetX" class="minilogo">
                <h1>QuantNetX</h1>
            </div>
            <p class="subtitle">Implied Probability Distribution - Risk-Neutral Probability from Options Prices</p>
        </header>

        <nav class="nav-bar">
            <a href="index.html" class="nav-link active">Options Analysis</a>
            <a href="bitcoin_risk.html" class="nav-link">Bitcoin Risk Metric</a>
            <a href="market_pairs.html" class="nav-link">Market Pairs</a>
        </nav>

        <div id="error" class="error" style="display: none;"></div>

        <div id="stats" class="stats-grid" style="display: none;"></div>

        <div class="info-box" id="methodInfo">
            <strong>Method:</strong> <span id="methodDescription">Implied probabilities are calculated using the second derivative of option prices (butterfly spread approach).
            The probability density at each strike is computed using finite differences for non-uniformly spaced strikes, then normalized to sum to 1.</span>
            Both call and put distributions are shown for comparison. They should theoretically match but may differ due to market microstructure, liquidity, and bid-ask spreads.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="currencySelect">Currency</label>
                <select id="currencySelect">
                    <option value="BTC">BTC</option>
                    <option value="ETH">ETH</option>
                </select>
            </div>
            <div class="control-group">
                <label for="expirySelect">Expiry Date</label>
                <select id="expirySelect">
                    <option value="">Loading expiries...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="methodSelect">Calculation Method</label>
                <select id="methodSelect">
                    <option value="finite-diff">Finite Differences (Breeden-Litzenberger)</option>
                    <option value="cubic-spline">Cubic Spline Interpolation</option>
                </select>
            </div>
            <div class="control-group">
                <label for="stepSelect">Strike Step Size</label>
                <select id="stepSelect">
                    <option value="1">Every Strike (1)</option>
                    <option value="2">Every 2nd Strike</option>
                    <option value="3">Every 3rd Strike</option>
                    <option value="4">Every 4th Strike</option>
                    <option value="5">Every 5th Strike</option>
                </select>
            </div>
            <div class="control-group">
                <button id="refreshBtn">Refresh Data</button>
            </div>
        </div>

        <div id="loading" class="loading" style="display: none;">Loading data...</div>

        <div class="chart-container" id="chartContainer" style="display: none;">
            <div id="probabilityChart"></div>
        </div>

        <div class="chart-container" id="cumulativeChartContainer" style="display: none;">
            <div id="cumulativeChart"></div>
        </div>

        <div class="chart-container" id="markPriceChartContainer" style="display: none;">
            <div style="margin-bottom: 15px;">
                <label for="derivativeSelect" style="margin-right: 10px;">Display:</label>
                <select id="derivativeSelect">
                    <option value="price">Mark Price</option>
                    <option value="first">First Derivative (Delta)</option>
                    <option value="second">Second Derivative (Gamma)</option>
                </select>
            </div>
            <div id="markPriceChart"></div>
        </div>

        <div class="chart-container" id="contourChartContainer" style="display: none;">
            <div id="contourChart"></div>
        </div>

        <div class="chart-container" id="calendarSpreadContainer">
            <h3 style="color: #e4e4e4; margin-bottom: 15px;">Calendar Spread Forward Volatility Analysis</h3>
            <div class="info-box" style="margin-bottom: 15px;">
                This shows the forward implied volatility between two expiry dates, useful for trading calendar spreads.
                <br><strong>Forward IV</strong> = sqrt((T2×IV2² - T1×IV1²) / (T2 - T1)), where T is time to expiry in years.
                <br><strong>Forward Factor (FF)</strong> = (FrontIV - ForwardIV) / ForwardIV - measures the relative difference between front month and forward volatility.
                <br>FF > 0: Front month IV higher than forward period (backwardation). FF < 0: Forward period IV higher (contango).
            </div>
            <div style="margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-end;">
                <div class="control-group">
                    <label for="calendarExpiry1">Near Expiry (T1)</label>
                    <select id="calendarExpiry1">
                        <option value="">Select expiry...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="calendarExpiry2">Far Expiry (T2)</label>
                    <select id="calendarExpiry2">
                        <option value="">Select expiry...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="calendarOptionType">Option Type</label>
                    <select id="calendarOptionType">
                        <option value="call">Calls</option>
                        <option value="put">Puts</option>
                        <option value="both">Both</option>
                    </select>
                </div>
            </div>
            <div id="calendarChart"></div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Global Variables
        // ============================================================================
        let allData = [];
        let availableExpiries = [];
        let probabilitySurfaceData = null;
        const DERIBIT_API_BASE = 'https://www.deribit.com/api/v2/public';

        // ============================================================================
        // Date and Time Utilities
        // ============================================================================

        // Parse expiry date string to timestamp
        function parseExpiryToTimestamp(expiryStr) {
            // Format: DDMMMYY (e.g., "14OCT25")
            const day = parseInt(expiryStr.substr(0, 2));
            const monthStr = expiryStr.substr(2, 3).toUpperCase();
            const year = 2000 + parseInt(expiryStr.substr(5, 2));

            const months = {
                'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,
                'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11
            };

            const month = months[monthStr];
            if (month === undefined) return null;

            // Deribit options expire at 8:00 UTC
            const date = new Date(Date.UTC(year, month, day, 8, 0, 0));
            return date.getTime();
        }

        // ============================================================================
        // API Data Fetching
        // ============================================================================

        // Load precomputed probability surface data
        async function loadProbabilitySurface() {
            try {
                const response = await fetch('../data/probability_surface.json');
                if (!response.ok) {
                    console.warn('Probability surface data not available');
                    return null;
                }
                probabilitySurfaceData = await response.json();
                return probabilitySurfaceData;
            } catch (error) {
                console.warn('Could not load probability surface:', error);
                return null;
            }
        }

        // Fetch available expiry dates from Deribit
        async function fetchAvailableExpiries(currency = 'BTC') {
            try {
                const response = await fetch(`${DERIBIT_API_BASE}/get_book_summary_by_currency?currency=${currency}&kind=option`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch instruments: ${response.statusText}`);
                }

                const data = await response.json();
                const instruments = data.result || [];

                // Extract unique expiry dates and calculate timestamps
                const expiryMap = new Map();
                instruments.forEach(instrument => {
                    const match = instrument.instrument_name.match(/\w+-(\w+)-\d+-[CP]/);
                    if (match) {
                        const expiryStr = match[1];
                        if (!expiryMap.has(expiryStr)) {
                            const timestamp = parseExpiryToTimestamp(expiryStr);
                            if (timestamp) {
                                expiryMap.set(expiryStr, timestamp);
                            }
                        }
                    }
                });

                return Array.from(expiryMap.entries())
                    .map(([expiry, timestamp]) => ({ expiry, timestamp }))
                    .sort((a, b) => a.timestamp - b.timestamp);
            } catch (error) {
                showError('Error fetching expiries: ' + error.message);
                return [];
            }
        }

        // Fetch option chain data from Deribit for a specific expiry
        async function fetchOptionChainData(currency = 'BTC', expiry) {
            try {
                const response = await fetch(`${DERIBIT_API_BASE}/get_book_summary_by_currency?currency=${currency}&kind=option`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.statusText}`);
                }

                const data = await response.json();
                const instruments = data.result || [];

                // Filter instruments by expiry
                const filteredInstruments = instruments.filter(instrument =>
                    instrument.instrument_name.includes(expiry)
                );

                // Transform to our data format
                const timestamp = new Date().toISOString();
                const transformedData = filteredInstruments.map(instrument => {
                    // Parse instrument name: BTC-14OCT25-80000-C
                    const match = instrument.instrument_name.match(/(\w+)-(\w+)-(\d+)-([CP])/);
                    if (!match) return null;

                    const [_, underlying, expiryDate, strike, optionType] = match;

                    return {
                        timestamp: timestamp,
                        instrument_name: instrument.instrument_name,
                        underlying: underlying,
                        expiry: expiryDate,
                        strike: parseFloat(strike),
                        option_type: optionType,
                        underlying_price: instrument.underlying_price,
                        underlying_index: instrument.underlying_index,
                        mark_price: instrument.mark_price,
                        mark_iv: instrument.mark_iv,
                        bid_price: instrument.bid_price,
                        ask_price: instrument.ask_price,
                        mid_price: instrument.mid_price,
                        last_price: instrument.last,
                        open_interest: instrument.open_interest,
                        volume: instrument.volume,
                        expiration_timestamp: parseExpiryToTimestamp(expiryDate)
                    };
                }).filter(item => item !== null);

                return transformedData;
            } catch (error) {
                showError('Error fetching option chain: ' + error.message);
                return [];
            }
        }

        // ============================================================================
        // Probability Calculation Functions
        // ============================================================================

        // ============================================================================
        // Cubic Spline Helper Functions
        // ============================================================================

        // Natural cubic spline implementation
        function cubicSpline(x, y) {
            const n = x.length - 1;
            const a = [...y];
            const b = new Array(n);
            const c = new Array(n + 1).fill(0);
            const d = new Array(n);
            const h = new Array(n);
            const alpha = new Array(n);
            const l = new Array(n + 1).fill(1);
            const mu = new Array(n + 1).fill(0);
            const z = new Array(n + 1).fill(0);

            // Calculate h values
            for (let i = 0; i < n; i++) {
                h[i] = x[i + 1] - x[i];
            }

            // Calculate alpha values
            for (let i = 1; i < n; i++) {
                alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1]);
            }

            // Solve tridiagonal system
            for (let i = 1; i < n; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }

            // Back substitution
            for (let j = n - 1; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }

            return { a, b, c, d, x };
        }

        // Evaluate cubic spline at a point
        function evalSpline(spline, xVal) {
            const { a, b, c, d, x } = spline;

            // Find the interval
            let i = 0;
            for (i = 0; i < x.length - 1; i++) {
                if (xVal <= x[i + 1]) break;
            }
            if (i >= a.length) i = a.length - 1;

            const dx = xVal - x[i];
            return a[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
        }

        // Evaluate second derivative of cubic spline
        function evalSplineSecondDerivative(spline, xVal) {
            const { c, d, x } = spline;

            // Find the interval
            let i = 0;
            for (i = 0; i < x.length - 1; i++) {
                if (xVal <= x[i + 1]) break;
            }
            if (i >= c.length) i = c.length - 1;

            const dx = xVal - x[i];
            return 2 * c[i] + 6 * d[i] * dx;
        }

        // ============================================================================
        // Method 1: Finite Differences (Breeden-Litzenberger) - Original Method
        // ============================================================================

        // Calculate probabilities from options using second derivative
        function calculateProbabilitiesFromOptions(options, underlyingPrice, method = 'finite-diff', stepSize = 1) {
            if (options.length < 3) {
                return [];
            }

            const probabilities = [];

            if (method === 'finite-diff') {
                // Original finite difference method with configurable step size
                for (let i = stepSize; i < options.length - stepSize; i++) {
                    const xa = options[i - stepSize].strike;
                    const xb = options[i].strike;
                    const xc = options[i + stepSize].strike;

                    const fa = options[i - stepSize].mark_price;
                    const fb = options[i].mark_price;
                    const fc = options[i + stepSize].mark_price;

                    const d1 = xb - xa;
                    const d2 = xc - xb;

                    if (d1 <= 0 || d2 <= 0) continue;

                    // Second derivative for non-uniformly spaced points
                    const secondDerivative = 2 * (fa * d2 + fc * d1 - fb * (d1 + d2)) / (d1 * d2 * (d1 + d2));

                    if (secondDerivative > 0) {
                        probabilities.push({
                            strike: xb,
                            probability: secondDerivative,
                            iv: options[i].mark_iv
                        });
                    }
                }
            } else if (method === 'cubic-spline') {
                // Cubic spline interpolation method
                const strikes = options.map(o => o.strike);
                const prices = options.map(o => o.mark_price);

                // Create cubic spline
                const spline = cubicSpline(strikes, prices);

                // Generate dense grid of strikes
                const minStrike = strikes[0];
                const maxStrike = strikes[strikes.length - 1];
                const numPoints = Math.max(100, strikes.length * 10);
                const strikeStep = (maxStrike - minStrike) / numPoints;

                for (let k = minStrike; k <= maxStrike - strikeStep; k += strikeStep) {
                    const secondDeriv = evalSplineSecondDerivative(spline, k);

                    if (secondDeriv > 0) {
                        // Find closest option for IV
                        const closestOption = options.reduce((prev, curr) =>
                            Math.abs(curr.strike - k) < Math.abs(prev.strike - k) ? curr : prev
                        );

                        probabilities.push({
                            strike: k,
                            probability: secondDeriv,
                            iv: closestOption.mark_iv
                        });
                    }
                }
            }

            if (probabilities.length === 0) {
                return [];
            }

            // Normalize so the distribution integrates to 1
            const totalProb = probabilities.reduce((sum, p) => sum + p.probability, 0);
            if (totalProb > 0) {
                probabilities.forEach(p => {
                    p.probability = p.probability / totalProb;
                });
            }

            return probabilities;
        }

        // Calculate implied probability distribution from both calls and puts
        function calculateImpliedProbability(optionsData, method = 'finite-diff', stepSize = 1) {
            // Filter and sort calls and puts
            const calls = optionsData
                .filter(d => d.option_type === 'C' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const puts = optionsData
                .filter(d => d.option_type === 'P' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            if (calls.length < 3 && puts.length < 3) {
                throw new Error('Insufficient data for probability calculation (need at least 3 call or put options)');
            }

            // Get underlying price
            const underlyingPrice = calls.length > 0 ? calls[0].underlying_price : puts[0].underlying_price;

            // Calculate time to expiry
            const expirationTimestamp = calls.length > 0 ? calls[0].expiration_timestamp : puts[0].expiration_timestamp;
            const now = Date.now();
            const timeToExpiry = (expirationTimestamp - now) / (1000 * 60 * 60 * 24 * 365);

            if (timeToExpiry <= 0) {
                throw new Error('Options have expired');
            }

            // Calculate probabilities from calls and puts
            let callProbabilities = calls.length >= 3 ?
                calculateProbabilitiesFromOptions(calls, underlyingPrice, method, stepSize) : [];

            let putProbabilities = puts.length >= 3 ?
                calculateProbabilitiesFromOptions(puts, underlyingPrice, method, stepSize) : [];

            if (callProbabilities.length === 0 && putProbabilities.length === 0) {
                throw new Error('No valid probabilities calculated from calls or puts');
            }

            const expiryDate = calls.length > 0 ? calls[0].expiry : puts[0].expiry;

            return {
                callProbabilities: callProbabilities,
                putProbabilities: putProbabilities,
                underlyingPrice: underlyingPrice,
                timeToExpiry: timeToExpiry,
                expiryDate: expiryDate
            };
        }

        // Calculate cumulative distribution
        function calculateCumulativeDistribution(probabilities) {
            const cumulative = [];
            let sum = 0;

            for (const p of probabilities) {
                sum += p.probability;
                cumulative.push({
                    strike: p.strike,
                    cumulative: sum
                });
            }

            return cumulative;
        }

        // ============================================================================
        // Derivative Calculation Functions (for visualization)
        // ============================================================================

        // Calculate first derivative (delta) using central differences
        function calculateFirstDerivative(options) {
            const derivatives = [];

            for (let i = 1; i < options.length - 1; i++) {
                const xa = options[i - 1].strike;
                const xb = options[i].strike;
                const xc = options[i + 1].strike;

                const fa = options[i - 1].mark_price;
                const fb = options[i].mark_price;
                const fc = options[i + 1].mark_price;

                const d1 = xb - xa;
                const d2 = xc - xb;

                if (d1 <= 0 || d2 <= 0) continue;

                // First derivative using non-uniform spacing
                const firstDeriv = (fc - fa) / (d1 + d2) + (d2 - d1) * (fc - 2*fb + fa) / ((d1 + d2) * d1 * d2);

                derivatives.push({
                    strike: xb,
                    value: firstDeriv
                });
            }

            return derivatives;
        }

        // Calculate second derivative (gamma) for non-uniform spacing
        function calculateSecondDerivative(options) {
            const derivatives = [];

            for (let i = 1; i < options.length - 1; i++) {
                const xa = options[i - 1].strike;
                const xb = options[i].strike;
                const xc = options[i + 1].strike;

                const fa = options[i - 1].mark_price;
                const fb = options[i].mark_price;
                const fc = options[i + 1].mark_price;

                const d1 = xb - xa;
                const d2 = xc - xb;

                if (d1 <= 0 || d2 <= 0) continue;

                // Second derivative for non-equally spaced points
                const secondDeriv = 2 * (fa * d2 + fc * d1 - fb * (d1 + d2)) / (d1 * d2 * (d1 + d2));

                derivatives.push({
                    strike: xb,
                    value: secondDeriv
                });
            }

            return derivatives;
        }

        // ============================================================================
        // Calendar Spread Forward Volatility Functions
        // ============================================================================

        // Calculate forward implied volatility between two expiries
        function calculateForwardVolatility(options1, options2, optionType = 'call') {
            // Filter and sort options by type
            const opts1 = options1
                .filter(d => d.option_type === (optionType === 'call' ? 'C' : 'P') && d.mark_iv > 0)
                .sort((a, b) => a.strike - b.strike);

            const opts2 = options2
                .filter(d => d.option_type === (optionType === 'call' ? 'C' : 'P') && d.mark_iv > 0)
                .sort((a, b) => a.strike - b.strike);

            if (opts1.length === 0 || opts2.length === 0) {
                return [];
            }

            // Get time to expiry in years
            const now = Date.now();
            const t1 = (opts1[0].expiration_timestamp - now) / (1000 * 60 * 60 * 24 * 365);
            const t2 = (opts2[0].expiration_timestamp - now) / (1000 * 60 * 60 * 24 * 365);

            if (t1 <= 0 || t2 <= 0) {
                return [];
            }

            // Find common strikes or interpolate
            const forwardVols = [];

            // For each strike in the first expiry, find corresponding second expiry strike
            opts1.forEach(opt1 => {
                const strike = opt1.strike;
                // Find exact match or closest strike in second expiry
                const opt2 = opts2.find(o => o.strike === strike) ||
                             opts2.reduce((prev, curr) =>
                                 Math.abs(curr.strike - strike) < Math.abs(prev.strike - strike) ? curr : prev
                             );

                if (opt2 && Math.abs(opt2.strike - strike) < strike * 0.05) { // Within 5% of strike
                    const iv1 = opt1.mark_iv / 100; // Convert from percentage to decimal
                    const iv2 = opt2.mark_iv / 100;

                    // Forward variance: Var_forward = (T2*IV2² - T1*IV1²) / (T2 - T1)
                    // No absolute value - can be negative if term structure is inverted
                    const forwardVariance = (t2 * iv2 * iv2 - t1 * iv1 * iv1) / (t2 - t1);

                    // Handle both positive and negative forward variance
                    // Negative indicates term structure inversion
                    const forwardVol = Math.sqrt(Math.abs(forwardVariance)) * 100 * Math.sign(forwardVariance);

                    // Calculate Forward Factor: FF = (FrontIV - ForwardIV) / ForwardIV
                    // FrontIV is IV1 (near expiry), ForwardIV is the calculated forward vol
                    const forwardFactor = forwardVol !== 0 ? (opt1.mark_iv - forwardVol) / forwardVol : 0;

                    forwardVols.push({
                        strike: strike,
                        forwardVol: forwardVol,
                        forwardFactor: forwardFactor,
                        iv1: opt1.mark_iv,
                        iv2: opt2.mark_iv,
                        t1: t1,
                        t2: t2
                    });
                }
            });

            return forwardVols;
        }

        // ============================================================================
        // UI Utility Functions
        // ============================================================================

        // Format number
        function formatNumber(num, decimals = 2) {
            if (!num || num === '') return '-';
            const n = parseFloat(num);
            if (isNaN(n)) return '-';
            return n.toLocaleString('en-US', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            });
        }

        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Hide error
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        // Helper to calculate stats from probabilities
        function calcStats(probs, underlyingPrice) {
            if (probs.length === 0) return null;

            const expectedPrice = probs.reduce((sum, p) => sum + p.strike * p.probability, 0);
            const variance = probs.reduce((sum, p) => sum + Math.pow(p.strike - expectedPrice, 2) * p.probability, 0);
            const stdDev = Math.sqrt(variance);
            const mode = probs.reduce((max, p) => p.probability > max.probability ? p : max, probs[0]);
            const probAbove = probs.filter(p => p.strike > underlyingPrice).reduce((sum, p) => sum + p.probability, 0);
            const probBelow = probs.filter(p => p.strike <= underlyingPrice).reduce((sum, p) => sum + p.probability, 0);

            return { expectedPrice, stdDev, mode, probAbove, probBelow };
        }

        // ============================================================================
        // UI Update Functions
        // ============================================================================

        // Update stats display
        function updateStats(result) {
            const statsDiv = document.getElementById('stats');

            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];

            if (callProbs.length === 0 && putProbs.length === 0) {
                statsDiv.style.display = 'none';
                return;
            }

            const underlyingPrice = result.underlyingPrice;
            const callStats = calcStats(callProbs, underlyingPrice);
            const putStats = calcStats(putProbs, underlyingPrice);

            let html = `
                <div class="stat-card">
                    <div class="stat-label">Current Price</div>
                    <div class="stat-value">$${formatNumber(underlyingPrice, 2)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Time to Expiry</div>
                    <div class="stat-value">${(result.timeToExpiry * 365).toFixed(0)} days</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Expiry Date</div>
                    <div class="stat-value">${result.expiryDate}</div>
                </div>
            `;

            if (callStats) {
                html += `
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Expected Price (Calls)</div>
                    <div class="stat-value">$${formatNumber(callStats.expectedPrice, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Std Dev (Calls)</div>
                    <div class="stat-value">$${formatNumber(callStats.stdDev, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #667eea;">
                    <div class="stat-label">Prob Above (Calls)</div>
                    <div class="stat-value">${(callStats.probAbove * 100).toFixed(1)}%</div>
                </div>
                `;
            }

            if (putStats) {
                html += `
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Expected Price (Puts)</div>
                    <div class="stat-value">$${formatNumber(putStats.expectedPrice, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Std Dev (Puts)</div>
                    <div class="stat-value">$${formatNumber(putStats.stdDev, 2)}</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid #ff6b9d;">
                    <div class="stat-label">Prob Below (Puts)</div>
                    <div class="stat-value">${(putStats.probBelow * 100).toFixed(1)}%</div>
                </div>
                `;
            }

            statsDiv.innerHTML = html;
            statsDiv.style.display = 'grid';
        }

        // ============================================================================
        // Plotting Functions
        // ============================================================================

        // Plot probability distribution
        function plotProbabilityDistribution(result) {
            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];
            const underlyingPrice = result.underlyingPrice;

            const traces = [];

            if (callProbs.length > 0) {
                traces.push({
                    x: callProbs.map(p => p.strike),
                    y: callProbs.map(p => p.probability * 100),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'From Calls',
                    line: {
                        color: '#667eea',
                        width: 3
                    },
                    marker: {
                        size: 6,
                        color: '#667eea'
                    },
                    fill: 'tozeroy',
                    fillcolor: 'rgba(102, 126, 234, 0.15)'
                });
            }

            if (putProbs.length > 0) {
                traces.push({
                    x: putProbs.map(p => p.strike),
                    y: putProbs.map(p => p.probability * 100),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'From Puts',
                    line: {
                        color: '#ff6b9d',
                        width: 3,
                        dash: 'dot'
                    },
                    marker: {
                        size: 6,
                        color: '#ff6b9d',
                        symbol: 'square'
                    },
                    fill: 'tozeroy',
                    fillcolor: 'rgba(255, 107, 157, 0.15)'
                });
            }

            const layout = {
                title: {
                    text: 'Implied Probability Distribution',
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: 'Probability Density (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '.2f'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }],
                annotations: [{
                    x: underlyingPrice,
                    y: 1,
                    yref: 'paper',
                    text: `Current: $${formatNumber(underlyingPrice, 0)}`,
                    showarrow: false,
                    font: { color: '#ffc107', size: 12 },
                    yanchor: 'bottom'
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            // WICHTIG: Container ZUERST sichtbar machen
            document.getElementById('chartContainer').style.display = 'block';

            // Dann Chart erstellen
            Plotly.newPlot('probabilityChart', traces, layout, config);

            // Und Resize erzwingen
            setTimeout(() => {
                Plotly.Plots.resize('probabilityChart');
            }, 100);
        }

        // Plot cumulative distribution
        function plotCumulativeDistribution(result) {
            const callProbs = result.callProbabilities || [];
            const putProbs = result.putProbabilities || [];
            const underlyingPrice = result.underlyingPrice;

            const traces = [];

            if (callProbs.length > 0) {
                const callCumulative = calculateCumulativeDistribution(callProbs);
                traces.push({
                    x: callCumulative.map(c => c.strike),
                    y: callCumulative.map(c => c.cumulative * 100),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'From Calls',
                    line: {
                        color: '#667eea',
                        width: 3
                    }
                });
            }

            if (putProbs.length > 0) {
                const putCumulative = calculateCumulativeDistribution(putProbs);
                traces.push({
                    x: putCumulative.map(c => c.strike),
                    y: putCumulative.map(c => c.cumulative * 100),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'From Puts',
                    line: {
                        color: '#ff6b9d',
                        width: 3,
                        dash: 'dot'
                    }
                });
            }

            const layout = {
                title: {
                    text: 'Cumulative Distribution Function',
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: 'Cumulative Probability (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    range: [0, 100]
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 0,
                    yanchor: 'bottom',
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 100,
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            // WICHTIG: Container ZUERST sichtbar machen
            document.getElementById('cumulativeChartContainer').style.display = 'block';

            // Dann Chart erstellen
            Plotly.newPlot('cumulativeChart', traces, layout, config);

            // Und Resize erzwingen
            setTimeout(() => {
                Plotly.Plots.resize('cumulativeChart');
            }, 100);
        }

        // Plot mark prices, first derivative, or second derivative
        function plotMarkPrices(optionsData, underlyingPrice) {
            const displayMode = document.getElementById('derivativeSelect').value;

            const calls = optionsData
                .filter(d => d.option_type === 'C' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const puts = optionsData
                .filter(d => d.option_type === 'P' && d.mark_price > 0)
                .sort((a, b) => a.strike - b.strike);

            const traces = [];
            let yAxisTitle = 'Mark Price';
            let chartTitle = 'Option Mark Prices';
            let yAxisFormat = '.4f';

            if (displayMode === 'price') {
                // Display mark prices
                yAxisTitle = 'Mark Price';
                chartTitle = 'Option Mark Prices';

                if (calls.length > 0) {
                    traces.push({
                        x: calls.map(c => c.strike),
                        y: calls.map(c => c.mark_price),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call Mark Prices',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length > 0) {
                    traces.push({
                        x: puts.map(p => p.strike),
                        y: puts.map(p => p.mark_price),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put Mark Prices',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            } else if (displayMode === 'first') {
                // Display first derivative (delta)
                yAxisTitle = 'First Derivative (dC/dK)';
                chartTitle = 'First Derivative of Option Prices';
                yAxisFormat = '.6f';

                if (calls.length >= 3) {
                    const callDerivs = calculateFirstDerivative(calls);
                    traces.push({
                        x: callDerivs.map(d => d.strike),
                        y: callDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call First Derivative',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length >= 3) {
                    const putDerivs = calculateFirstDerivative(puts);
                    traces.push({
                        x: putDerivs.map(d => d.strike),
                        y: putDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put First Derivative',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            } else if (displayMode === 'second') {
                // Display second derivative (gamma)
                yAxisTitle = 'Second Derivative (d²C/dK²)';
                chartTitle = 'Second Derivative of Option Prices';
                yAxisFormat = '.8f';

                if (calls.length >= 3) {
                    const callDerivs = calculateSecondDerivative(calls);
                    traces.push({
                        x: callDerivs.map(d => d.strike),
                        y: callDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Call Second Derivative',
                        line: { color: '#667eea', width: 3 },
                        marker: { size: 6, color: '#667eea' }
                    });
                }

                if (puts.length >= 3) {
                    const putDerivs = calculateSecondDerivative(puts);
                    traces.push({
                        x: putDerivs.map(d => d.strike),
                        y: putDerivs.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Put Second Derivative',
                        line: { color: '#ff6b9d', width: 3 },
                        marker: { size: 6, color: '#ff6b9d', symbol: 'square' }
                    });
                }
            }

            const layout = {
                title: {
                    text: chartTitle,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: yAxisTitle,
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: yAxisFormat
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }],
                annotations: [{
                    x: underlyingPrice,
                    y: 1,
                    yref: 'paper',
                    text: `Current: $${formatNumber(underlyingPrice, 0)}`,
                    showarrow: false,
                    font: { color: '#ffc107', size: 12 },
                    yanchor: 'bottom'
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            // WICHTIG: Container ZUERST sichtbar machen
            document.getElementById('markPriceChartContainer').style.display = 'block';

            // Dann Chart erstellen
            Plotly.newPlot('markPriceChart', traces, layout, config);

            // Und Resize erzwingen
            setTimeout(() => {
                Plotly.Plots.resize('markPriceChart');
            }, 100);
        }

        // Plot probability contour (price vs time)
        async function plotProbabilityContour() {
            if (!probabilitySurfaceData) {
                console.warn('Probability surface data not available');
                return;
            }

            const currency = document.getElementById('currencySelect').value;

            if (!probabilitySurfaceData.surfaces || !probabilitySurfaceData.surfaces[currency]) {
                console.warn(`No surface data for ${currency}`);
                return;
            }

            const surfaceData = probabilitySurfaceData.surfaces[currency].combined_surface;
            const currentPrice = surfaceData.current_price;

            // Load implied probabilities to get expected prices
            let expectedPrices = [];
            try {
                const response = await fetch('../data/implied_probabilities.json');
                if (response.ok) {
                    const probData = await response.json();
                    const currencyData = probData.currencies[currency];

                    // Extract expected prices for each expiry
                    for (const expiryKey in currencyData) {
                        const expiryData = currencyData[expiryKey];
                        const expiryTimestamp = expiryData.expiration_timestamp / 1000; // Convert to seconds
                        const expectedPrice = expiryData.call_statistics?.expected_price;

                        if (expectedPrice && expiryTimestamp) {
                            expectedPrices.push({
                                time: new Date(expiryTimestamp * 1000),
                                price: expectedPrice
                            });
                        }
                    }

                    // Sort by time
                    expectedPrices.sort((a, b) => a.time - b.time);
                }
            } catch (error) {
                console.warn('Could not load expected prices:', error);
            }

            // Extract grid data
            const timeUnix = surfaceData.grid.time_unix;  // Unix timestamps in seconds
            const timeDates = surfaceData.grid.time_dates;  // ISO date strings
            const prices = surfaceData.grid.prices;
            const probabilities = surfaceData.grid.probabilities; // 2D array [price_index][time_index]

            // Convert Unix timestamps to Date objects (multiply by 1000 for milliseconds)
            const dateObjects = timeUnix.map(ts => new Date(ts * 1000));

            // Normalize probabilities: for each time (column), scale by the max at that time
            const numPrices = probabilities.length;
            const numTimes = probabilities[0].length;

            // Find max for each time slice
            const maxByTime = [];
            for (let t = 0; t < numTimes; t++) {
                let maxVal = 0;
                for (let p = 0; p < numPrices; p++) {
                    if (probabilities[p][t] > maxVal) {
                        maxVal = probabilities[p][t];
                    }
                }
                maxByTime.push(maxVal);
            }

            // Normalize by max**0.75 and convert to percentage
            const probabilitiesPercent = probabilities.map(row =>
                row.map((val, t) => maxByTime[t] > 0 ? (val / Math.pow(maxByTime[t], 0.75)) * 100 : 0)
            );

            // Custom colorscale: blue -> cyan -> yellow -> red with transparency for low values (ggplot2 style)
            const customColorscale = [
                [0, 'rgba(0, 0, 255, 0)'],        // Transparent blue
                [0.15, 'rgba(0, 0, 255, 0.2)'],   // Low opacity blue
                [0.3, 'rgba(0, 127, 255, 0.5)'],  // Medium opacity cyan-blue
                [0.5, 'rgba(0, 255, 255, 0.8)'],  // Higher opacity cyan
                [0.7, 'rgba(255, 255, 0, 1)'],    // Full opacity yellow
                [0.85, 'rgba(255, 127, 0, 1)'],   // Full opacity orange
                [1, 'rgba(255, 0, 0, 1)']         // Full opacity red
            ];

            const traces = [];

            // Heatmap trace
            traces.push({
                z: probabilitiesPercent,
                x: dateObjects,
                y: prices,
                type: 'heatmap',
                colorscale: customColorscale,
                colorbar: {
                    title: 'Probability<br>Density (%)',
                    titleside: 'right',
                    thickness: 15,
                    len: 0.7,
                    bgcolor: 'rgba(0, 0, 0, 0.5)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1,
                    tickfont: { color: '#e4e4e4' },
                    titlefont: { color: '#e4e4e4' }
                },
                hovertemplate: 'Date: %{x|%b %d, %Y}<br>Price: $%{y:,.0f}<br>Prob: %{z:.3f}%<extra></extra>'
            });

            // Expected price line trace
            if (expectedPrices.length > 0) {
                traces.push({
                    x: expectedPrices.map(p => p.time),
                    y: expectedPrices.map(p => p.price),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Expected Price',
                    line: {
                        color: '#ffc107',
                        width: 1,
                        dash: 'dash'
                    },
                    hovertemplate: 'Date: %{x|%b %d, %Y}<br>Expected: $%{y:,.0f}<extra></extra>'
                });
            }

            const layout = {
                title: {
                    text: `${currency} Implied Probability Surface (Price vs Time)`,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Expiry Date',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    type: 'date'
                },
                yaxis: {
                    title: 'Price (USD)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            document.getElementById('contourChartContainer').style.display = 'block';
            Plotly.newPlot('contourChart', traces, layout, config);

            setTimeout(() => {
                Plotly.Plots.resize('contourChart');
            }, 100);
        }

        // Plot calendar spread forward volatility
        function plotCalendarSpreadVolatility(callForwardVols, putForwardVols, underlyingPrice, expiry1, expiry2) {
            const traces = [];

            if (callForwardVols && callForwardVols.length > 0) {
                traces.push({
                    x: callForwardVols.map(v => v.strike),
                    y: callForwardVols.map(v => v.forwardVol),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Call Forward IV',
                    line: { color: '#667eea', width: 3 },
                    marker: { size: 6, color: '#667eea' },
                    customdata: callForwardVols.map(v => v.forwardFactor),
                    hovertemplate: '<b>Call Forward IV</b><br>' +
                                   'Strike: $%{x:,.0f}<br>' +
                                   'Forward IV: %{y:.2f}%<br>' +
                                   'Forward Factor: %{customdata:.3f}<br>' +
                                   '<extra></extra>'
                });

                // Add near and far IV lines for calls
                traces.push({
                    x: callForwardVols.map(v => v.strike),
                    y: callForwardVols.map(v => v.iv1),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Call IV (${expiry1})`,
                    line: { color: '#667eea', width: 1, dash: 'dot' },
                    opacity: 0.5,
                    hovertemplate: 'Strike: $%{x:,.0f}<br>IV: %{y:.2f}%<extra></extra>'
                });

                traces.push({
                    x: callForwardVols.map(v => v.strike),
                    y: callForwardVols.map(v => v.iv2),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Call IV (${expiry2})`,
                    line: { color: '#667eea', width: 1, dash: 'dash' },
                    opacity: 0.5,
                    hovertemplate: 'Strike: $%{x:,.0f}<br>IV: %{y:.2f}%<extra></extra>'
                });

                // Add Forward Factor for calls
                traces.push({
                    x: callForwardVols.map(v => v.strike),
                    y: callForwardVols.map(v => v.forwardFactor * 100), // Convert to percentage
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Call Forward Factor (%)',
                    line: { color: '#48bb78', width: 2 },
                    yaxis: 'y2',
                    hovertemplate: 'Strike: $%{x:,.0f}<br>FF: %{y:.2f}%<extra></extra>'
                });
            }

            if (putForwardVols && putForwardVols.length > 0) {
                traces.push({
                    x: putForwardVols.map(v => v.strike),
                    y: putForwardVols.map(v => v.forwardVol),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Put Forward IV',
                    line: { color: '#ff6b9d', width: 3 },
                    marker: { size: 6, color: '#ff6b9d', symbol: 'square' },
                    customdata: putForwardVols.map(v => v.forwardFactor),
                    hovertemplate: '<b>Put Forward IV</b><br>' +
                                   'Strike: $%{x:,.0f}<br>' +
                                   'Forward IV: %{y:.2f}%<br>' +
                                   'Forward Factor: %{customdata:.3f}<br>' +
                                   '<extra></extra>'
                });

                // Add near and far IV lines for puts
                traces.push({
                    x: putForwardVols.map(v => v.strike),
                    y: putForwardVols.map(v => v.iv1),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Put IV (${expiry1})`,
                    line: { color: '#ff6b9d', width: 1, dash: 'dot' },
                    opacity: 0.5,
                    hovertemplate: 'Strike: $%{x:,.0f}<br>IV: %{y:.2f}%<extra></extra>'
                });

                traces.push({
                    x: putForwardVols.map(v => v.strike),
                    y: putForwardVols.map(v => v.iv2),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Put IV (${expiry2})`,
                    line: { color: '#ff6b9d', width: 1, dash: 'dash' },
                    opacity: 0.5,
                    hovertemplate: 'Strike: $%{x:,.0f}<br>IV: %{y:.2f}%<extra></extra>'
                });

                // Add Forward Factor for puts
                traces.push({
                    x: putForwardVols.map(v => v.strike),
                    y: putForwardVols.map(v => v.forwardFactor * 100), // Convert to percentage
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Put Forward Factor (%)',
                    line: { color: '#f6ad55', width: 2 },
                    yaxis: 'y2',
                    hovertemplate: 'Strike: $%{x:,.0f}<br>FF: %{y:.2f}%<extra></extra>'
                });
            }

            const layout = {
                title: {
                    text: `Forward Implied Volatility: ${expiry1} to ${expiry2}`,
                    font: { color: '#e4e4e4', size: 20 }
                },
                xaxis: {
                    title: 'Strike Price',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '$,.0f'
                },
                yaxis: {
                    title: 'Implied Volatility (%)',
                    color: '#a0a0a0',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    tickformat: '.1f'
                },
                yaxis2: {
                    title: {
                        text: 'Forward Factor (%)',
                        font: { color: '#48bb78' }
                    },
                    color: '#48bb78',
                    overlaying: 'y',
                    side: 'right',
                    showgrid: false,
                    tickformat: '.1f',
                    zeroline: true,
                    zerolinecolor: 'rgba(72, 187, 120, 0.5)',
                    zerolinewidth: 2
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'rgba(0, 0, 0, 0)',
                font: { color: '#e4e4e4' },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    x: 0.5,
                    xanchor: 'center',
                    y: -0.2,
                    yanchor: 'top',
                    orientation: 'h',
                    bgcolor: 'rgba(0, 0, 0, 0.7)',
                    bordercolor: 'rgba(255, 255, 255, 0.2)',
                    borderwidth: 1
                },
                shapes: [{
                    type: 'line',
                    x0: underlyingPrice,
                    x1: underlyingPrice,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: '#ffc107',
                        width: 2,
                        dash: 'dash'
                    }
                }],
                annotations: [{
                    x: underlyingPrice,
                    y: 1,
                    yref: 'paper',
                    text: `Current: $${formatNumber(underlyingPrice, 0)}`,
                    showarrow: false,
                    font: { color: '#ffc107', size: 12 },
                    yanchor: 'bottom'
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('calendarChart', traces, layout, config);

            setTimeout(() => {
                Plotly.Plots.resize('calendarChart');
            }, 100);
        }

        // ============================================================================
        // Event Handlers
        // ============================================================================

        // Update method description based on selected method
        function updateMethodDescription() {
            const method = document.getElementById('methodSelect').value;
            const descriptionSpan = document.getElementById('methodDescription');

            const descriptions = {
                'finite-diff': 'Implied probabilities are calculated using the Breeden-Litzenberger formula: the second derivative of option prices with respect to strike. Uses finite differences for non-uniformly spaced strikes.',
                'cubic-spline': 'Uses cubic spline interpolation to create a smooth function through option prices, then computes the second derivative analytically. Provides smoother distributions with more data points.'
            };

            descriptionSpan.textContent = descriptions[method] || descriptions['finite-diff'];
        }

        // Handle expiry selection - fetch data and calculate probabilities
        async function handleExpiryChange() {
            const selectedExpiry = document.getElementById('expirySelect').value;
            const selectedCurrency = document.getElementById('currencySelect').value;
            const selectedMethod = document.getElementById('methodSelect').value;
            const selectedStepSize = parseInt(document.getElementById('stepSelect').value);

            if (!selectedExpiry) {
                document.getElementById('chartContainer').style.display = 'none';
                document.getElementById('cumulativeChartContainer').style.display = 'none';
                document.getElementById('markPriceChartContainer').style.display = 'none';
                document.getElementById('contourChartContainer').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('loading').style.display = 'block';
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('cumulativeChartContainer').style.display = 'none';
            document.getElementById('markPriceChartContainer').style.display = 'none';
            document.getElementById('contourChartContainer').style.display = 'none';
            document.getElementById('stats').style.display = 'none';

            try {
                // Fetch data from Deribit
                allData = await fetchOptionChainData(selectedCurrency, selectedExpiry);

                if (allData.length === 0) {
                    throw new Error('No data available for the selected expiry');
                }

                // Calculate implied probabilities using selected method and step size
                const result = calculateImpliedProbability(allData, selectedMethod, selectedStepSize);

                if (result.callProbabilities.length === 0 && result.putProbabilities.length === 0) {
                    throw new Error('Unable to calculate probabilities (insufficient valid data)');
                }

                // Update UI
                updateStats(result);
                plotProbabilityDistribution(result);
                plotCumulativeDistribution(result);
                plotMarkPrices(allData, result.underlyingPrice);

                // Plot contour if data is available
                if (probabilitySurfaceData) {
                    plotProbabilityContour();
                }

            } catch (error) {
                showError(error.message);
            }

            document.getElementById('loading').style.display = 'none';
        }

        // Load available expiries from Deribit
        async function loadExpiries() {
            const currency = document.getElementById('currencySelect').value;
            const expirySelect = document.getElementById('expirySelect');

            hideError();
            expirySelect.innerHTML = '<option value="">Loading expiries...</option>';
            expirySelect.disabled = true;

            const expiries = await fetchAvailableExpiries(currency);

            if (expiries.length > 0) {
                expirySelect.innerHTML = '<option value="">Select an expiry...</option>';
                expiries.forEach(({ expiry, timestamp }) => {
                    const option = document.createElement('option');
                    option.value = expiry;
                    const daysToExpiry = Math.floor((timestamp - Date.now()) / (1000 * 60 * 60 * 24));
                    option.textContent = `${expiry} (${daysToExpiry}d)`;
                    expirySelect.appendChild(option);
                });
                availableExpiries = expiries;

                // Update calendar spread expiry dropdowns
                updateCalendarExpiryOptions();

                // Auto-select first expiry
                expirySelect.value = expiries[0].expiry;
                handleExpiryChange();
            } else {
                expirySelect.innerHTML = '<option value="">No expiries available</option>';
                showError('Failed to load expiries from Deribit');
            }

            expirySelect.disabled = false;
        }

        // ============================================================================
        // Event Listeners Setup
        // ============================================================================

        // Currency change - reset and reload expiries
        document.getElementById('currencySelect').addEventListener('change', () => {
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('cumulativeChartContainer').style.display = 'none';
            document.getElementById('markPriceChartContainer').style.display = 'none';
            document.getElementById('contourChartContainer').style.display = 'none';
            document.getElementById('stats').style.display = 'none';
            loadExpiries();
        });

        // Expiry change - recalculate probabilities
        document.getElementById('expirySelect').addEventListener('change', handleExpiryChange);

        // Method change - update description and recalculate
        document.getElementById('methodSelect').addEventListener('change', () => {
            updateMethodDescription();
            const selectedExpiry = document.getElementById('expirySelect').value;
            if (selectedExpiry) {
                handleExpiryChange();
            }
        });

        // Step size change - recalculate probabilities
        document.getElementById('stepSelect').addEventListener('change', () => {
            const selectedExpiry = document.getElementById('expirySelect').value;
            if (selectedExpiry) {
                handleExpiryChange();
            }
        });

        // Derivative display mode change - update chart
        document.getElementById('derivativeSelect').addEventListener('change', () => {
            if (allData.length > 0) {
                const underlyingPrice = allData[0].underlying_price;
                plotMarkPrices(allData, underlyingPrice);
            }
        });

        // Refresh button - reload current data
        document.getElementById('refreshBtn').addEventListener('click', () => {
            const selectedExpiry = document.getElementById('expirySelect').value;
            if (selectedExpiry) {
                handleExpiryChange();
            } else {
                loadExpiries();
            }
        });

        // Calendar spread expiry 1 change - recalculate automatically
        document.getElementById('calendarExpiry1').addEventListener('change', () => {
            const expiry1 = document.getElementById('calendarExpiry1').value;
            const expiry2 = document.getElementById('calendarExpiry2').value;
            if (expiry1 && expiry2) {
                handleCalendarSpreadCalculation();
            }
        });

        // Calendar spread expiry 2 change - recalculate automatically
        document.getElementById('calendarExpiry2').addEventListener('change', () => {
            const expiry1 = document.getElementById('calendarExpiry1').value;
            const expiry2 = document.getElementById('calendarExpiry2').value;
            if (expiry1 && expiry2) {
                handleCalendarSpreadCalculation();
            }
        });

        // Calendar option type change - recalculate automatically
        document.getElementById('calendarOptionType').addEventListener('change', () => {
            const expiry1 = document.getElementById('calendarExpiry1').value;
            const expiry2 = document.getElementById('calendarExpiry2').value;
            if (expiry1 && expiry2) {
                handleCalendarSpreadCalculation();
            }
        });

        // Handle calendar spread calculation
        async function handleCalendarSpreadCalculation() {
            const expiry1 = document.getElementById('calendarExpiry1').value;
            const expiry2 = document.getElementById('calendarExpiry2').value;
            const optionType = document.getElementById('calendarOptionType').value;
            const currency = document.getElementById('currencySelect').value;

            if (!expiry1 || !expiry2) {
                showError('Please select both expiry dates');
                return;
            }

            hideError();
            document.getElementById('loading').style.display = 'block';

            try {
                // Fetch option data for both expiries
                const [options1, options2] = await Promise.all([
                    fetchOptionChainData(currency, expiry1),
                    fetchOptionChainData(currency, expiry2)
                ]);

                if (options1.length === 0 || options2.length === 0) {
                    throw new Error('No data available for one or both expiries');
                }

                const underlyingPrice = options1[0].underlying_price;

                // Calculate forward volatilities
                let callForwardVols = null;
                let putForwardVols = null;

                if (optionType === 'call' || optionType === 'both') {
                    callForwardVols = calculateForwardVolatility(options1, options2, 'call');
                    if (callForwardVols.length === 0) {
                        console.warn('No valid call forward volatilities calculated');
                    }
                }

                if (optionType === 'put' || optionType === 'both') {
                    putForwardVols = calculateForwardVolatility(options1, options2, 'put');
                    if (putForwardVols.length === 0) {
                        console.warn('No valid put forward volatilities calculated');
                    }
                }

                if ((!callForwardVols || callForwardVols.length === 0) &&
                    (!putForwardVols || putForwardVols.length === 0)) {
                    throw new Error('Unable to calculate forward volatilities (insufficient data)');
                }

                // Plot the forward volatilities
                plotCalendarSpreadVolatility(callForwardVols, putForwardVols, underlyingPrice, expiry1, expiry2);

            } catch (error) {
                showError('Error calculating calendar spread: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Populate calendar spread expiry dropdowns
        function updateCalendarExpiryOptions() {
            const calendarExpiry1 = document.getElementById('calendarExpiry1');
            const calendarExpiry2 = document.getElementById('calendarExpiry2');

            // Copy expiries from main dropdown
            if (availableExpiries.length > 0) {
                calendarExpiry1.innerHTML = '<option value="">Select near expiry...</option>';
                calendarExpiry2.innerHTML = '<option value="">Select far expiry...</option>';

                availableExpiries.forEach(({ expiry, timestamp }) => {
                    const option1 = document.createElement('option');
                    option1.value = expiry;
                    const daysToExpiry = Math.floor((timestamp - Date.now()) / (1000 * 60 * 60 * 24));
                    option1.textContent = `${expiry} (${daysToExpiry}d)`;
                    calendarExpiry1.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = expiry;
                    option2.textContent = `${expiry} (${daysToExpiry}d)`;
                    calendarExpiry2.appendChild(option2);
                });

                // Auto-select two suitable expiries (not too close to today)
                // Find expiries that are at least 7 days away
                const suitableExpiries = availableExpiries.filter(({ timestamp }) => {
                    const daysToExpiry = (timestamp - Date.now()) / (1000 * 60 * 60 * 24);
                    return daysToExpiry >= 7;
                });

                if (suitableExpiries.length >= 2) {
                    // Select first suitable expiry for near date
                    calendarExpiry1.value = suitableExpiries[0].expiry;

                    // Select an expiry at least 14 days after the first one for far date
                    const nearTimestamp = suitableExpiries[0].timestamp;
                    const farExpiry = suitableExpiries.find(({ timestamp }) =>
                        (timestamp - nearTimestamp) >= 14 * 24 * 60 * 60 * 1000
                    );

                    if (farExpiry) {
                        calendarExpiry2.value = farExpiry.expiry;
                        // Automatically calculate on load
                        setTimeout(() => handleCalendarSpreadCalculation(), 500);
                    } else if (suitableExpiries.length > 1) {
                        // Fallback: just use the second available expiry
                        calendarExpiry2.value = suitableExpiries[1].expiry;
                        setTimeout(() => handleCalendarSpreadCalculation(), 500);
                    }
                }
            }
        }

        // ============================================================================
        // Initialization
        // ============================================================================

        // Initialize on page load
        async function initialize() {
            updateMethodDescription();

            // Load probability surface data first (don't block on errors)
            await loadProbabilitySurface().catch(err => {
                console.warn('Failed to load probability surface:', err);
            });

            // Then load expiries and auto-select first one
            loadExpiries();
        }

        initialize();

        // Window Resize Handler - resize charts when window is resized
        window.addEventListener('resize', () => {
            if (document.getElementById('chartContainer').style.display !== 'none') {
                Plotly.Plots.resize('probabilityChart');
            }
            if (document.getElementById('cumulativeChartContainer').style.display !== 'none') {
                Plotly.Plots.resize('cumulativeChart');
            }
            if (document.getElementById('markPriceChartContainer').style.display !== 'none') {
                Plotly.Plots.resize('markPriceChart');
            }
            if (document.getElementById('contourChartContainer').style.display !== 'none') {
                Plotly.Plots.resize('contourChart');
            }
            // Calendar chart is always visible
            Plotly.Plots.resize('calendarChart');
        });
    </script>
</body>
</html>
